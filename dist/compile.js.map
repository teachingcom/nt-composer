{"version":3,"sources":["../compile/cache.js","../compile/paths.js","../compile/utils.js","../compile/compression.json","../compile/create-sprite-padded-spritesheet.js","../compile/consts.js","../compile/overrides.js","../compile/generate-spritesheet.js","../compile/generate-resource.js","../compile/scan-directory.js","../compile/generate-resource-from-dir.js","../compile/generate-sounds-spritesheet.js","../compile/splitManifest.js","../compile/compile.js","../compile/index.js"],"names":["data","load","path","content","fs","readFile","parsed","JSON","parse","toString","Object","assign","ex","paths","exec","script","INPUT_DIR","OUTPUT_DIR","process","argv","resolve","replacePaths","inputDir","outputDir","readYml","exists","contents","yml","console","error","getDirectoryContents","dir","markup","images","files","readdir","file","source","stat","isDirectory","lastModified","mtime","ext","extname","ref","indexOf","push","asyncCallback","action","args","Promise","reject","err","res","fileToKey","_","snakeCase","basename","timeout","time","setTimeout","module","exports","jpeg_quality","png_max_palette_colors","createSpritePaddedSpritesheet","target","width","height","coordinates","padding","canvas","ctx","getContext","halfPadding","waiting","then","image","x","y","drawImage","all","buffer","toBuffer","fsx","writeFile","ASSET_TYPES","HASHED_ASSET_TYPES","ASSET_TYPE_SOURCES","trail","cars","fanfare","nametags","nitros","normalizeAssetTypeName","type","replace","normalizePublicKeyName","name","filePath","src","getOverrides","overrides","readFileSync","COMPRESSION_PARAMS","JPG_COMPRESSION_ARGS","PNG_COMPRESSION_ARGS","generateSpritesheet","spritesheets","nodeId","spritesheetName","subdir","isPublic","knownAs","category","substr","length","key","includes","crypto","createHash","update","digest","basePath","pngPath","jpgPath","jpgs","filter","item","test","pngs","hasPngs","some","hasJpgs","generatedTimes","getModifiedTime","lastGenerated","expired","Math","min","apply","isNaN","log","existing","get","cache","sprites","version","Date","now","hasPng","createSpritesheetFromImages","hasJpg","tmpId","resourceDir","dirname","tmpDir","mkdirp","verify","check","checkFor","existsSync","writeFileSync","count","jpegArgs","pngArgs","compression","jpg_quality","png_colors","compress_force","statistic","autoupdate","jpg","engine","command","png","svg","gif","completed","removeSync","spritesheetId","saveTo","useSpriteAsPadding","map","properties","Spritesmith","run","bounds","Error","statSync","generateResource","root","node","id","options","pathId","public","scanDirectory","dirs","location","isHidden","allowType","allowFiles","allowHidden","generateResourcesFromDirectory","isMP3","generateSoundSprites","checkForUpdatedSounds","sounds","collections","items","generateCollectionSoundSprites","copyIndividualSounds","glob","ts","parseInt","mtimeMs","output","readdirSync","sound","copyFrom","copyAndCompressAudio","entries","entry","record","tmp","gap","generated","spritemap","start","end","compare","copyTo","copyMP3s","input","on","audioBitrate","audioChannels","mergeToFile","splitManifest","manifest","remove","obj","standard","stringify","keys","DEBUG","VERSION","compile","overridesPath","exported","tracks","trails","intro","extras","trackName","fullTrackDir","variant","generateKeyMap","mapping","sources","config","hash","utils","allUtils"],"mappings":"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","file":"compile.js","sourceRoot":"../compile","sourcesContent":["import fs from 'fs-extra'\n\n/** the previous version of the file */\nexport const data = { }\n\n// tries to load the previous document, if any\nexport async function load (path) {\n  try {\n    const content = await fs.readFile(path)\n    const parsed = JSON.parse(content.toString())\n    Object.assign(data, parsed)\n    // wasn't able to restore the file\n  } catch (ex) { }\n}\n","import path from 'path';\nconst [ exec, script, INPUT_DIR, OUTPUT_DIR ] = (process.argv || [ ]);\n\n// get the root path\nconst paths = { \n\tOUTPUT_DIR: path.resolve(INPUT_DIR || ''),\n\tINPUT_DIR: path.resolve(OUTPUT_DIR || ''),\n};\n\nexport function replacePaths(inputDir, outputDir) {\n\tpaths.INPUT_DIR = inputDir;\n\tpaths.OUTPUT_DIR = outputDir;\n}\n\nexport default paths;","import _ from 'lodash';\nimport fs from 'fs-extra';\nimport path from 'path';\nimport yml from 'js-yaml';\n\n/** reads a YML file */\nexport async function readYml(path) {\n\n\t// make sure this exists\n\tconst exists = await fs.exists(path);\n\tif (!exists) return null;\n\n\t// try and read the content\n\ttry {\n\t\tconst contents = await fs.readFile(path);\n\t\treturn yml.load(contents.toString());\n\t}\n\tcatch (ex) {\n\t\tconsole.error(`YAML Error in ${path}`);\n\t\tthrow ex;\n\t}\n}\n\n/** gather up contents for a directory */\nexport async function getDirectoryContents(dir) {\n\tlet markup = [ ];\n\tlet images = [ ];\n\n\t// get modified times for each file\n\tconst files = await fs.readdir(dir);\n\tfor (let file of files) {\n\n\t\t// get the source\n\t\tconst source = path.resolve(`${dir}/${file}`);\n\t\tconst stat = await fs.stat(source);\n\t\tconst isDirectory = stat.isDirectory();\n\t\tconst lastModified = +stat.mtime;\n\t\tconst ext = path.extname(file);\n\t\t\n\t\t// skip directories and hidden files\n\t\tif (isDirectory || file[0] === '.') continue;\n\n\t\t// add to the correct group\n\t\tconst ref = !!~['.yml', '.yaml'].indexOf(ext) ? markup\n\t\t\t: !!~['.jpg', '.jpeg', '.png'].indexOf(ext) ? images\n\t\t\t: null;\n\n\t\t// create the record\n\t\tif (ref) ref.push({ path: source, lastModified });\n\t}\n\n\treturn { markup, images };\n}\n\n/** perfoms a callback as an async call */\nexport async function asyncCallback(action, ...args) {\n\treturn new Promise((resolve, reject) => {\n\t\taction(...args, (err, ...res) => {\n\t\t\tif (err) reject(err);\n\t\t\telse resolve(...res);\n\t\t});\n\t});\n}\n\n/** generates a key from a file name or path */\nexport function fileToKey(file) {\n\treturn _.snakeCase(path.basename(file, path.extname(file)))\n}\n\n/** waits a specified time */\nexport async function timeout(time) {\n\treturn new Promise(resolve => {\n\t\tsetTimeout(resolve, time);\n\t});\n}","module.exports={jpeg_quality:80,png_max_palette_colors:128};","import * as fsx from 'fs-extra';\nimport { createCanvas, loadImage } from \"canvas\";\nimport { fileToKey } from \"./utils\";\n\n// generates a spritesheet that uses the sprite as padding\n// this is helpful when the rendering engine does a bad job\n// at preventing bleed on textures and you're not using\n// an image with transparency\nexport async function createSpritePaddedSpritesheet(target, width, height, coordinates, padding) {\n\tconst canvas = createCanvas(width, height);\n\tconst ctx = canvas.getContext('2d');\n\tconst halfPadding = padding / 2;\n\n\tconst waiting = [ ];\n\tfor (const file in coordinates) {\n\t\twaiting.push(\n\t\t\tloadImage(file).then(image => {\n\t\t\t\tconst { x, y, width, height } = coordinates[file];\n\n\t\t\t\t// render the bonus area and then draw the image\n\t\t\t\t// over the top\n\t\t\t\tctx.drawImage(image, x - halfPadding, y - halfPadding, width + padding, height + padding);\n\t\t\t\tctx.drawImage(image, x, y, width, height);\n\t\t\t}));\n\t}\n\n\t// wait for all drawings\n\tawait Promise.all(waiting);\n\n\t// save the final image\n\tconst buffer = canvas.toBuffer();\n\tawait fsx.writeFile(target, buffer);\n}","\nexport const ASSET_TYPES = [\n\t'nametags',\n\t'trails',\n\t'cars',\n\t'nitros',\n\t'fanfare'\n]\n\nexport const HASHED_ASSET_TYPES = [\n\t...ASSET_TYPES,\n\t'nametag',\n\t'trail',\n\t'car',\n\t'nitro',\n\t'fanfare'\n]\n\nexport const ASSET_TYPE_SOURCES = { \n\ttrail: 'trails', \n\tcars: 'cars', \n\tfanfare: 'fanfare', \n\tnametags: 'nametags', \n\tnitros: 'nitros' \n}\n\n// need to rename some paths to match\n// item types in the game\nexport function normalizeAssetTypeName(type) {\n    return type.replace(/^trails/, 'trail')\n      .replace(/^nitros/, 'nitros')\n      .replace(/^nametags/, 'nametags')\n      .replace(/^fanfares/, 'fanfare')\n}\n\nexport function normalizePublicKeyName(name) {\n\treturn name.replace(/namecards/, 'nametag')\n\t\t.replace(/nametags/, 'nametag')\n\t\t.replace(/nitros/, 'nitro')\n}","import fs from 'fs-extra'\nimport path from 'path'\n\nlet filePath\n\nexport async function load(src) {\n  filePath = path.resolve(src)\n}\n\nexport function getOverrides() {\n  const overrides = { }\n  try {\n    const data = JSON.parse(fs.readFileSync(filePath).toString())\n    Object.assign(overrides, data)\n  }\n  catch (ex) {\n    console.error('failed to read overrides.json')\n    throw ex\n  }\n\n  return overrides\n}","import _ from 'lodash'\nimport fs from 'fs-extra'\nimport path from 'path'\nimport Spritesmith from 'spritesmith'\nimport compressImages from 'compress-images'\n\nimport COMPRESSION_PARAMS from './compression.json'\nimport { fileToKey, asyncCallback, timeout } from './utils.js'\nimport paths from './paths.js'\nimport * as cache from './cache.js'\nimport { createSpritePaddedSpritesheet } from './create-sprite-padded-spritesheet'\nimport crypto from 'crypto';\nimport { HASHED_ASSET_TYPES, normalizeAssetTypeName, normalizePublicKeyName } from './consts'\nimport { getOverrides } from './overrides.js'\n\n// compression args\nconst { jpeg_quality, png_max_palette_colors } = COMPRESSION_PARAMS\nconst JPG_COMPRESSION_ARGS = ['-quality', jpeg_quality]\nconst PNG_COMPRESSION_ARGS = [png_max_palette_colors, '-f', '--strip', '--skip-if-larger']\n\nexport async function generateSpritesheet (spritesheets, nodeId, spritesheetName, subdir, images, isPublic) {\n  const overrides = getOverrides()\n  const { OUTPUT_DIR } = paths\n  const knownAs = spritesheetName || nodeId;\n  const src = `${subdir}${knownAs}`\n  const category = subdir.substr(0, subdir.length - 1)\n\n  // check if requires obfuscation\n  let key = src\n  key = normalizeAssetTypeName(key)\n\n  // if hashing the type\n  if (HASHED_ASSET_TYPES.includes(category) && !isPublic) {\n    key = normalizePublicKeyName(key)\n    key = crypto.createHash('sha1').update(key).digest('hex')\n  }\n\n  // get the possible paths\n  const basePath = path.resolve(`${OUTPUT_DIR}/${src}`)\n  const pngPath = `${basePath}.png`\n  const jpgPath = `${basePath}.jpg`\n\n  // check for certain type\n  const jpgs = _.filter(images, item => /jpe?g$/i.test(item.path))\n  const pngs = _.filter(images, item => /png$/i.test(item.path))\n\n  // check for available images\n  const hasPngs = _.some(pngs)\n  const hasJpgs = _.some(jpgs)\n\n  // check each time, but only if the image type is expected\n  const generatedTimes = []\n  if (hasPngs) generatedTimes.push(getModifiedTime(pngPath))\n  if (hasJpgs) generatedTimes.push(getModifiedTime(jpgPath))\n  let lastGenerated = Math.min.apply(Math, generatedTimes)\n  if (isNaN(lastGenerated)) lastGenerated = 0\n\n  // if all of the images have a lower write time\n  // than the sprite sheet then we don't need to compile it again\n  let expired\n  for (const item of images) {\n    expired = expired || item.lastModified > lastGenerated\n  }\n\n  // check if forcing a release\n  // TODO: maybe move outside of this function\n  if (/release/i.test(process.argv)) {\n    console.log('[release] force generate', key)\n    expired = true;\n  }\n\n  // check and make sure the prior data is available\n  const existing = _.get(cache.data, 'spritesheets', { })[key]\n\n  // if it's not expired and we have the old info then\n  // we can just reuse it\n  if (!expired && existing) {\n    spritesheets[key] = existing\n    return\n  }\n\n  // save the new spritesheet location\n  const sprites = spritesheets[key] = { }\n  sprites.version = Date.now().toString(16)\n\n  // generate PNGs\n  if (hasPngs) {\n    sprites.hasPng = true\n    await createSpritesheetFromImages(src, sprites, pngs, pngPath)\n  }\n\n  // generate JPGs\n  if (hasJpgs) {\n    sprites.hasJpg = true\n    await createSpritesheetFromImages(src, sprites, jpgs, jpgPath, true)\n  }\n\n  // there seems to be some timing issues - give a moment to\n  // settle down before compressing - ideally, we can just\n  // pipe results eventually\n  await timeout(5000)\n\n  // verify the resource directory\n  const tmpId = _.snakeCase(src)\n  const resourceDir = `dist${path.dirname(basePath).substr(OUTPUT_DIR.length)}`\n  const tmpDir = `${resourceDir}/_${tmpId}`\n  await fs.mkdirp(resourceDir)\n\n  // if the target image doesn't exist, just create something to be a placeholder so the\n  // file size comparison doesn't fail in compressImages\n\n  const verify = [ ];\n  if (hasPngs) verify.push(`${_.snakeCase(knownAs)}.png`);\n  if (hasJpgs) verify.push(`${_.snakeCase(knownAs)}.jpg`);\n  for (const check of verify) {\n    const checkFor = path.resolve(resourceDir, check);\n    if (!fs.existsSync(checkFor)) {\n      fs.writeFileSync(checkFor, '');\n    }\n  }\n\n  // track files before removing\n  let count = 0\n  if (hasJpgs) count++\n  if (hasPngs) count++\n\n  // update configs\n  const jpegArgs = [...JPG_COMPRESSION_ARGS]\n  const pngArgs = [...PNG_COMPRESSION_ARGS]\n\n  // check for overrides\n  const compression = overrides[tmpId]\n  jpegArgs[1] = compression?.jpg_quality ?? compression?.jpeg_quality ?? jpegArgs[1]\n  pngArgs[0] = compression?.png_colors ?? pngArgs[0]\n\n  // notify of params\n  console.log(`New Compress Compression Params\n  jpeg_quality           : ${jpegArgs}\n  png_max_palette_colors : ${pngArgs}`)\n\n  // compress resources\n  return new Promise((resolve, reject) => {\n    compressImages(\n      `${tmpDir}/*.{jpg,png}`, // input\n      `${resourceDir}/`, // output\n      {\n        compress_force: true,\n        statistic: true,\n        autoupdate: false\n      },\n      false, // ??\n      { jpg: { engine: 'mozjpeg', command: jpegArgs } },\n      { png: { engine: 'pngquant', command: pngArgs } },\n      { svg: { engine: false, command: false } },\n      { gif: { engine: false, command: false } },\n\n      // finalize\n      async function (error, completed, statistic) {\n        \n        // remove the temporary generation dir\n        if (--count <= 0) {\n          fs.removeSync(tmpDir)\n        }\n\n        // check for errors\n        if (error) {\n          console.error(`Compression failure for ${resourceDir}`)\n          console.error(error)\n          resolve()\n          // compressed as expected\n        } else {\n          resolve()\n        }\n      })\n  })\n}\n\n// updates the spritesheet with image names\nasync function createSpritesheetFromImages (spritesheetId, sprites, images, saveTo, useSpriteAsPadding) {\n  const padding = 2\n\n  // convert to a spritesheet\n  const src = _.map(images, item => item.path)\n  const { image, coordinates, properties } = await asyncCallback(Spritesmith.run, { padding, src })\n  const ext = path.extname(saveTo).substr(1)\n\n  // simplify the output format\n  for (const file in coordinates) {\n    const bounds = coordinates[file]\n    const name = fileToKey(file)\n\n    // if this name already exists, then there's a conflict in\n    // names and needs to be stopped\n    if (sprites[name]) {\n      throw new Error(`Conflicting sprite name: ${name} in ${spritesheetId}`)\n    }\n\n    sprites[name] = [bounds.x, bounds.y, bounds.width, bounds.height, ext]\n  }\n\n  // write the image\n  const tmpId = _.snakeCase(spritesheetId)\n  const dir = `${path.dirname(saveTo)}/_${tmpId}`\n  const target = `${dir}/${path.basename(saveTo)}`\n  await fs.mkdirp(dir)\n\n  // create the padded version\n  if (useSpriteAsPadding) {\n    await createSpritePaddedSpritesheet(target, properties.width, properties.height, coordinates, padding)\n  }\n  // use the normal image\n  else {\n    await fs.writeFile(target, image, 'binary')\n  }\n}\n\n// check the last modified time for a file, if it exists\nfunction getModifiedTime (path) {\n  try {\n    return fs.statSync(path).mtime || 0\n  } catch (ex) {\n    return 0\n  }\n}\n","import _ from 'lodash'\nimport fs from 'fs-extra'\nimport path from 'path'\n\nimport { getDirectoryContents, readYml, fileToKey } from './utils.js'\nimport { generateSpritesheet } from './generate-spritesheet.js'\nimport paths from './paths.js'\n\n/** generates a resource item */\nexport default async function generateResource (root, node, id, options) {\n  const { INPUT_DIR } = paths\n  const hasSubdir = !!options.subdir\n  const subdir = hasSubdir ? `${options.subdir}/` : ''\n  const pathId = `${subdir}${id}`\n  const dir = path.resolve(`${INPUT_DIR}/${pathId}`)\n  const nodeId = options.nodeId || id\n\n  // if it's missing, don't bother\n  // there will be a separate process to remove\n  // files that no longer exist so cleanup is not required\n  const exists = await fs.exists(dir)\n  if (!exists) return\n\n  // gather file contents\n  console.log('[generating]', pathId)\n  const { images, markup } = await getDirectoryContents(dir, options)\n\n  // copy all YML data\n  const data = { }\n  for (const item of markup) {\n    const contents = await readYml(item.path)\n    const key = fileToKey(item.path)\n\n    // assign the data -- for a default index file, just assign the data\n    if (key === 'index') Object.assign(data, contents)\n    else data[key] = contents\n  }\n\n  // save the data, if any\n  if (_.some(data)) {\n    node[nodeId] = data\n  }\n\n  // generate the spritesheet, if any\n  if (_.some(images)) {\n    const { spritesheetName } = options\n    const isPublic = !!data?.public\n    await generateSpritesheet(root.spritesheets, id, spritesheetName, subdir, images, isPublic)\n  }\n}\n","import path from 'path';\nimport fs from 'fs-extra';\n\n/** handles checking a directory for content */\nexport default async function scanDirectory(source, options, action) {\n\n\t// doesn't exist yet\n\tconst exists = await fs.exists(source);\n\tif (!exists) return;\n\n\t// gather all sub folders\n\tconst dirs = await fs.readdir(source);\n\tfor (const dir of dirs) {\n\n\t\t// make sure it's not a hidden file and\n\t\t// is actually a directory\n\t\tconst location = path.resolve(`${source}/${dir}`);\n\t\tconst stat = await fs.stat(location);\n\t\tconst isHidden = dir[0] === '.';\n\t\tconst isDirectory = stat.isDirectory();\n\t\tconst allowType = isDirectory || (!isDirectory && options.allowFiles);\n\t\tconst allowHidden = !isHidden || (isHidden && options.allowHidden);\n\n\t\t// continue with this resource\n\t\tif (allowType && allowHidden) \n\t\t\tawait action(dir, location);\n\t}\n\n}","import path from 'path';\nimport paths from './paths.js';\nimport generateResource from './generate-resource.js';\nimport scanDirectory from './scan-directory.js';\n\n/** generates a resource from each item in a directory */\nexport default async function generateResourcesFromDirectory(root, node, id, options) {\n\tconst { INPUT_DIR } = paths;\n\tconst source = path.resolve(`${INPUT_DIR}/${id}`);\n\t\n\t// if the node is missing, create it\n\tif (!node) {\n\t\tnode = { };\n\t\troot[id] = node;\n\t}\n\n\t// process all diles in a directory\n\tawait scanDirectory(source, { }, async dir => {\n\t\tawait generateResource(root, node, dir, { nodeId: dir, subdir: id });\n\t});\n}","import fs from 'fs-extra'\nimport path from 'path'\nimport fluent from 'fluent-ffmpeg'\nimport audiosprite from 'audiosprite'\nimport paths from './paths.js'\nimport glob from 'glob'\nimport { equalFiles } from 'file-sync-cmp'\nimport { asyncCallback } from './utils.js'\n\nconst isMP3 = path => /\\.mp3$/i.test(path)\n\nexport default async function generateSoundSprites (root, cache) {\n  // check for new sounds to compile\n  const hasUpdatedSounds = await checkForUpdatedSounds(cache)\n  if (!hasUpdatedSounds) {\n    root.sounds = cache.data.sounds\n    return\n  }\n\n  root.sounds = { }\n\n  // find all collections of audio\n  const { INPUT_DIR } = paths\n  const dir = 'sounds/collections'\n  const collections = path.resolve(INPUT_DIR, dir)\n  const items = await fs.readdir(collections);\n\n  // generate each unique sound spritesheet\n  for (const name of items) {\n    const location = path.resolve(collections, name)\n    const stat = await fs.stat(location)\n    if (stat.isDirectory() && !/^\\./.test(name)) {\n      await generateCollectionSoundSprites(root, name, location)\n    }\n  }\n\n  // copy other individual sounds\n  await copyIndividualSounds(root)\n}\n\nasync function checkForUpdatedSounds(cache) {\n  const { INPUT_DIR } = paths\n  const files = await asyncCallback(glob, `${INPUT_DIR}/sounds/**/*.mp3`)\n  \n  // find the latest timestamp\n  const ts = parseInt(cache.data?.version, '16')\n\n  // see if anything is newer\n  for (const file of files) {\n    const stat = fs.statSync(file)\n    if (stat.mtimeMs > ts) {\n      return true\n    }\n  }\n\n  // nothing new\n  return false\n}\n\nasync function copyIndividualSounds(root) {\n  const { INPUT_DIR, OUTPUT_DIR } = paths\n  const dir = 'sounds'\n  const collections = path.resolve(INPUT_DIR, dir)\n  const items = await fs.readdir(collections);\n\n  // generate each unique sound spritesheet\n  for (const name of items) {\n    const location = path.resolve(collections, name)\n    const stat = await fs.stat(location)\n    if (stat.isDirectory() && name !== 'collections' && !/^\\./.test(name)) {\n      const type = path.basename(location);\n      const output = path.resolve(`${OUTPUT_DIR}/sounds/${type}`)\n\n      // check for mp3s\n      const files = fs.readdirSync(location).filter(item => /\\.mp3/i.test(item))\n      for (const file of files) {\n        const sound = file.replace(/\\.mp3$/, '');\n        const copyFrom = path.resolve(location, file)\n        const saveTo = path.resolve(output, file)\n        const fileStat = fs.statSync(copyFrom)\n\n        // find the latest timestamp\n        const ts = 0 | fileStat.mtimeMs.toString(16);\n        \n        // mark this as a sound that exists\n        const key = `${name}/${sound}`;\n        root.sounds[key] = ts;\n        \n        // write the file\n        console.log('[sound]', key)\n        copyAndCompressAudio(copyFrom, saveTo)\n      }\n    }\n  }\n}\n\nasync function generateCollectionSoundSprites(root, name, location) {\n  const { OUTPUT_DIR } = paths\n\n  // collect possible sprites\n  const files = []\n  const entries = await fs.readdir(location)\n  for (const entry of entries) {\n    // filter out hidden files\n    if (/^\\./i.test(entry)) continue\n\n    // check the file info\n    const file = path.resolve(location, entry)\n\n    // if is an mp3 file\n    if (isMP3(file)) {\n      files.push(file)\n    }\n  }\n  \n  // create the sound record\n  const record = root.sounds[name] = { }\n\n  // check for required files\n  return new Promise((resolve, reject) => {\n    const tmp = path.resolve('./.compiled-audio')\n    const output = path.resolve(OUTPUT_DIR, 'sounds')\n    const options = {\n      gap: 0.5,\n      output: `${tmp}/${name}`\n    }\n\n    // create the spritesheet\n    audiosprite(files, options, async (err, generated) => {\n      if (err) {\n        return reject(err)\n      }\n\n      // map all audio files\n      for (const id in generated.spritemap) {\n        const sound = generated.spritemap[id]\n        record[id] = [0 | sound.start * 1000, 0 | (sound.end - sound.start) * 1000]\n      }\n\n      // compare the spritesheets to determine if they\n      // changed, and if so, update the timestamp\n      const source = `${tmp}/${name}.mp3`\n      const compare = `${output}/${name}.mp3`\n      const hasExisting = fs.existsSync(compare)\n      const same = hasExisting && equalFiles(source, compare)\n      if (!same) {\n        record.version = Date.now().toString('16')\n        console.log(`[audio] updated version: ${name}.mp3`)\n\n        // copy and compress each\n        const files = fs.readdirSync(tmp)\n        for (const file of files) {\n          const copyFrom = path.resolve(tmp, file)\n          const copyTo = path.resolve(output, file)\n          await copyAndCompressAudio(copyFrom, copyTo)\n        }\n      }\n\n      resolve()\n    })\n  })\n}\n\n// copy and compress each MP3 in a directory\nasync function copyMP3s(root, dir, { input, output }) {\n  const { INPUT_DIR, OUTPUT_DIR } = paths\n  \n  if (!input) {\n    input = path.resolve(INPUT_DIR, dir)\n  }\n\n  if (!output) {\n    output = path.resolve(OUTPUT_DIR, dir)\n  }\n\n  const entries = await fs.readdir(input)\n  for (const entry of entries) {\n    // ensure it's an mp3\n    if (!isMP3(entry)) continue\n\n    // make the directory, if needed\n    const exists = await fs.exists(output)\n    if (!exists) await fs.mkdirp(output)\n\n    // copy the file\n    const key = `${dir}/${entry}`;\n    const source = path.resolve(input, entry)\n    const target = path.resolve(output, entry)\n    const stat = await fs.stat(source)\n\n    // copy the compressed version\n    root.sounds[key] = stat.mtime.toString('16')\n    await copyAndCompressAudio(source, target)\n    console.log(`[audio] ${key}`)\n  }\n}\n\n// handles copying individual MP3 files\nasync function copyAndCompressAudio(input, output) {\n  return new Promise((resolve, reject) => {\n    fluent()\n\n      // get the file top copy\n      .input(input)\n\n      // handle events\n      .on('end', resolve)\n      .on('error', reject)\n\n      // configure audio\n      .audioBitrate(48)\n      .audioChannels(1)\n\n      // then merge it\n      .mergeToFile(output)\n  })\n}\n","import fs from 'fs-extra'\nimport path from 'path'\nimport { ASSET_TYPES } from './consts'\n\nexport default async function splitManifest ({ manifest, outputDir }) {\n  // save each asset type as a separate file\n  for (const type of ASSET_TYPES) {\n    console.log(`[manifest] creating external manifests for ${type}`)\n    const dir = path.resolve(outputDir, `./${type}`)\n\n    // remove all existing JSON files first\n    if (fs.existsSync(dir)) {\n      const files = await fs.readdir(dir)\n      for (const file of files) {\n        if (path.extname(file) === '.json') {\n          const remove = path.resolve(dir, file)\n          await fs.remove(remove)\n        }\n      }\n    }\n\n    // copy each type into its own file\n    for (const id in manifest[type]) {\n      const obj = manifest[type][id]\n\n      // is standard and should be included\n      // in the default manifest\n      if (obj.standard) {\n        continue\n      }\n\n      // should be dynamically loaded\n      const output = JSON.stringify(obj)\n      const target = path.resolve(`${dir}/${id}.json`)\n      await fs.writeFile(target, output)\n\n      // remove this item\n      delete manifest[type][id]\n    }\n\n    // remove the manifest section if nothing remains\n    if (Object.keys(manifest[type]).length === 0) {\n      delete manifest[type]\n    }\n  }\n}\n","import fs from 'fs-extra'\nimport path from 'path'\nimport * as cache from './cache.js'\nimport paths, { replacePaths } from './paths.js'\nimport crypto from 'crypto'\n\n// resource generation approaches\nimport generateResource from './generate-resource.js'\nimport generateResourcesFromDirectory from './generate-resource-from-dir.js'\nimport scanDirectory from './scan-directory.js'\nimport generateSoundsSpritesheet from './generate-sounds-spritesheet.js'\nimport splitManifest from './splitManifest.js'\nimport { ASSET_TYPE_SOURCES, normalizeAssetTypeName, normalizePublicKeyName } from './consts.js'\nimport { load as loadOverrides } from './overrides.js'\n\n// check if debugging mode should be used\nconst DEBUG = !!~process.argv.indexOf('--debug')\nconst VERSION = '1.5.2'\n\n/** handles compiling all resources in the repo folder */\nexport async function compile (inputDir, outputDir, overridesPath) {\n  loadOverrides(overridesPath)\n\n  // it's somewhat difficult to ensure the composer is\n  // the correct version when used from different repos\n  // this will make it known which version is being run\n  console.log(`nt-composer: v${VERSION}`)\n\n  // change the input/output directories\n  if (inputDir && outputDir) {\n    replacePaths(inputDir, outputDir)\n  }\n\n  // prepare the data\n  const { INPUT_DIR, OUTPUT_DIR } = paths\n  const exported = path.resolve(`${OUTPUT_DIR}/manifest.json`)\n\n  // load the previous document into the cache\n  await cache.load(exported)\n\n  // ensure directories\n  await fs.mkdirp(OUTPUT_DIR)\n\n  // TODO: restore data\n  // check for changes\n  const data = { }\n  if (!('spritesheets' in data)) data.spritesheets = { }\n  if (!('tracks' in data)) data.tracks = { }\n\n  // start generating files\n  await generateResource(data, data, 'particles', { })\n  await generateResource(data, data, 'images', { })\n  await generateResource(data, data, 'animations', { })\n  await generateResource(data, data, 'emitters', { })\n  await generateResource(data, data, 'crowd', { })\n\n  // generate resources that have sub files\n  await generateResourcesFromDirectory(data, data.trails, 'trails', { })\n  await generateResourcesFromDirectory(data, data.intro, 'intros', { })\n  await generateResourcesFromDirectory(data, data.nitros, 'nitros', { })\n  await generateResourcesFromDirectory(data, data.cars, 'cars', { })\n  await generateResourcesFromDirectory(data, data.nametags, 'nametags', { })\n  await generateResourcesFromDirectory(data, data.fanfare, 'fanfare', { })\n  await generateResourcesFromDirectory(data, data.extras, 'extras', { })\n\n  // tracks have variations so each directory should\n  // be scanned to see all available types\n  await scanDirectory(`${INPUT_DIR}/tracks`, { }, async (trackName, fullTrackDir) => {\n    // save the track node\n    data.tracks[trackName] = { }\n\n    // create all variations\n    await scanDirectory(fullTrackDir, { }, async variant => {\n      data.tracks[trackName][variant] = { }\n\n      // generate a resource per variation\n      await generateResource(data, data.tracks[trackName], variant, {\n        subdir: `tracks/${trackName}`\n      })\n    })\n  })\n\n  // create the sounds, if needed\n  await generateSoundsSpritesheet(data, cache)\n\n  // save a version number to force manifest files\n  // to reload with\n  data.version = Date.now().toString('16')\n\n  // break up non-required manifest data\n  await splitManifest({ manifest: data, outputDir: OUTPUT_DIR })\n\n  // create a keymap for local development\n  await generateKeyMap()\n\n  // save the completed file\n  const output = JSON.stringify(data, null, DEBUG ? 2 : null)\n  console.log(`[export] ${exported}`)\n  await fs.writeFile(exported, output)\n}\n\n\nasync function generateKeyMap() {\n  const { INPUT_DIR, OUTPUT_DIR } = paths\n\n  const mapping = { }\n  const sources = ASSET_TYPE_SOURCES\n  for (const key in sources) {\n    const src = sources[key]\n    mapping[src] = { }\n\n    const dir = path.resolve(`${INPUT_DIR}/${src}`)\n    const files = await fs.readdir(dir)\n    for (const file of files) {\n      \n      // verify this is an actual resource\n      const config = `${dir}/${file}/index.yml`\n      if (!fs.existsSync(config)) {\n        console.log('not', config)\n        continue\n      }\n\n      // save the mapping\n      const ref = `${normalizePublicKeyName(normalizeAssetTypeName(key))}/${file}`\n      const hash = crypto.createHash('sha1').update(ref).digest('hex')\n      mapping[src][hash] = file\n    }\n  }\n\n  // save the result\n  const output = path.resolve(`${OUTPUT_DIR}/mapping.json`)\n  const data = JSON.stringify(mapping)\n  await fs.writeFile(output, data)\n}\n","export { compile } from './compile.js';\nimport * as allUtils from './utils.js';\nexport const utils = allUtils;"]}