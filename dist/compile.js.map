{"version":3,"sources":["cache.js","utils.js","../paths.js","generate-spritesheet.js","generate-resource.js","scan-directory.js","generate-resource-from-dir.js","generate-sounds-spritesheet.js","compile-progress-path.js","index.js"],"names":["data","load","path","content","fs","readFile","parsed","JSON","parse","toString","Object","assign","ex","readYml","exists","contents","yml","console","error","getDirectoryContents","dir","markup","images","files","readdir","file","source","resolve","stat","isDirectory","lastModified","mtime","ext","extname","ref","indexOf","push","asyncCallback","action","args","Promise","reject","err","res","fileToKey","_","snakeCase","basename","timeout","time","setTimeout","exec","script","INPUT_DIR","OUTPUT_DIR","process","argv","paths","log","JPG_COMPRESSION_ARGS","PNG_COMPRESSION_ARGS","generateSpritesheet","spritesheets","nodeId","spritesheetName","subdir","spritesheetId","basePath","pngPath","jpgPath","jpgs","filter","item","test","pngs","hasPngs","some","hasJpgs","generatedTimes","getModifiedTime","lastGenerated","expired","Math","min","apply","isNaN","existing","get","cache","sprites","hasPng","createSpritesheetFromImages","hasJpg","tmpId","resourceDir","dirname","substr","length","tmpDir","mkdirp","compress_force","statistic","autoupdate","jpg","engine","command","png","svg","gif","completed","remove","saveTo","src","map","image","coordinates","Spritesmith","run","bounds","name","Error","x","y","width","height","target","writeFile","statSync","generateResource","root","node","id","options","pathId","key","scanDirectory","dirs","location","isHidden","allowType","allowFiles","allowHidden","generateResourcesFromDirectory","generateSoundSprites","input","entries","entry","isMP3","buffer","duration","copyMP3s","silence","silenceBuffer","spacer","sounds","sprite","output","mergeMP3FilesToOutput","copyAndCompressMP3","on","audioBitrate","audioChannels","mergeToFile","concat","base","compileProgressPath","offsetX","offsetY","extractFile","points","distance","extractPoints","createProgress","doc","xml2js","parseStringPromise","rect","$","d","omgsvg","SVGPathParser","seek_next_cmd","parse_cur_args","index","isStart","dist","previous","hypot","isLine","cx1","cy1","cx2","cy2","curve","Bezier","isBezier","progress","normalizePoint","max","current","segment","round","lut","getLUT","point","t","i","DEBUG","compile","exported","tracks","trails","intro","nitros","cars","namecards","extras","trackName","fullTrackDir","variant","animations","crowd","generated","stringify"],"mappings":"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","file":"compile.js","sourceRoot":"../compile","sourcesContent":["import fs from 'fs-extra';\n\n/** the previous version of the file */\nexport const data = { };\n\n// tries to load the previous document, if any\nexport async function load(path) {\n\ttry {\n\t\tconst content = await fs.readFile(path);\n\t\tconst parsed = JSON.parse(content.toString());\n\t\tObject.assign(data, parsed);\n\t}\n\t// wasn't able to restore the file\n\tcatch (ex) { }\n}\n","import _ from 'lodash';\nimport fs from 'fs-extra';\nimport path from 'path';\nimport yml from 'js-yaml';\n\n/** reads a YML file */\nexport async function readYml(path) {\n\n\t// make sure this exists\n\tconst exists = await fs.exists(path);\n\tif (!exists) return null;\n\n\t// try and read the content\n\ttry {\n\t\tconst contents = await fs.readFile(path);\n\t\treturn yml.load(contents.toString());\n\t}\n\tcatch (ex) {\n\t\tconsole.error(`YAML Error in ${path}`);\n\t\tthrow ex;\n\t}\n}\n\n/** gather up contents for a directory */\nexport async function getDirectoryContents(dir) {\n\tlet markup = [ ];\n\tlet images = [ ];\n\n\t// get modified times for each file\n\tconst files = await fs.readdir(dir);\n\tfor (let file of files) {\n\n\t\t// get the source\n\t\tconst source = path.resolve(`${dir}/${file}`);\n\t\tconst stat = await fs.stat(source);\n\t\tconst isDirectory = stat.isDirectory();\n\t\tconst lastModified = +stat.mtime;\n\t\tconst ext = path.extname(file);\n\t\t\n\t\t// skip directories and hidden files\n\t\tif (isDirectory || file[0] === '.') continue;\n\n\t\t// add to the correct group\n\t\tconst ref = !!~['.yml', '.yaml'].indexOf(ext) ? markup\n\t\t\t: !!~['.jpg', '.jpeg', '.png'].indexOf(ext) ? images\n\t\t\t: null;\n\n\t\t// create the record\n\t\tif (ref) ref.push({ path: source, lastModified });\n\t}\n\n\treturn { markup, images };\n}\n\n/** perfoms a callback as an async call */\nexport async function asyncCallback(action, ...args) {\n\treturn new Promise((resolve, reject) => {\n\t\taction(...args, (err, ...res) => {\n\t\t\tif (err) reject(err);\n\t\t\telse resolve(...res);\n\t\t});\n\t});\n}\n\n/** generates a key from a file name or path */\nexport function fileToKey(file) {\n\treturn _.snakeCase(path.basename(file, path.extname(file)))\n}\n\n/** waits a specified time */\nexport async function timeout(time) {\n\treturn new Promise(resolve => {\n\t\tsetTimeout(resolve, time);\n\t});\n}","import path from 'path';\nconst [ exec, script, INPUT_DIR, OUTPUT_DIR ] = process.argv;\n\n// get the root path\nconst paths = { \n\tOUTPUT_DIR: path.resolve(INPUT_DIR),\n\tINPUT_DIR: path.resolve(OUTPUT_DIR),\n};\n\nexport default paths;\n\nconsole.log(paths);","import _ from 'lodash';\nimport fs from 'fs-extra';\nimport path from 'path';\nimport Spritesmith from 'spritesmith';\nimport compressImages from 'compress-images';\n\nimport { fileToKey, asyncCallback, timeout } from './utils.js';\nimport paths from '../paths.js';\nimport * as cache from './cache.js';\n\n// compression args\nconst JPG_COMPRESSION_ARGS = ['-quality', '65'];\nconst PNG_COMPRESSION_ARGS = [128, '-f', '--strip' /*, '--skip-if-larger' */];\n\nexport async function generateSpritesheet(spritesheets, nodeId, spritesheetName, subdir, images) {\n\tconst { OUTPUT_DIR } = paths;\n\tconst spritesheetId = `${subdir}${spritesheetName || nodeId}`;\n\n\t// get the possible paths\n\tconst basePath = path.resolve(`${OUTPUT_DIR}/${spritesheetId}`);\n\tconst pngPath = `${basePath}.png`;\n\tconst jpgPath = `${basePath}.jpg`;\n\n\t// check for certain type\n\tconst jpgs = _.filter(images, item => /jpe?g$/i.test(item.path));\n\tconst pngs = _.filter(images, item => /png$/i.test(item.path));\n\n\t// check if \n\tconst hasPngs = _.some(pngs);\n\tconst hasJpgs = _.some(jpgs);\n\n\t// check each time, but only if the image type is expected\n\tconst generatedTimes = [ ];\n\tif (hasPngs) generatedTimes.push(getModifiedTime(pngPath));\n\tif (hasJpgs) generatedTimes.push(getModifiedTime(jpgPath));\n\tlet lastGenerated = Math.min.apply(Math, generatedTimes);\n\tif (isNaN(lastGenerated)) lastGenerated = 0;\n\n\t// if all of the images have a lower write time\n\t// than the sprite sheet then we don't need to compile it again\n\tlet expired;\n\tfor (const item of images) {\n\t\texpired = expired || item.lastModified > lastGenerated;\n\t}\n\n\t// check and make sure the prior data is available\n\tconst existing = _.get(cache.data, 'spritesheets', { })[spritesheetId];\n\t\n\t// if it's not expired and we have the old info then\n\t// we can just reuse it\n\tif (!expired && existing) {\n\t\tspritesheets[spritesheetId] = existing;\n\t\treturn;\n\t}\n\n\t// save the new spritesheet location\n\tconst sprites = spritesheets[spritesheetId] = { };\n\n\t// generate PNGs\n\tif (hasPngs) {\n\t\tsprites.hasPng = true;\n\t\tawait createSpritesheetFromImages(spritesheetId, sprites, pngs, pngPath);\n\t}\n\t\n\t// generate JPGs\n\tif (hasJpgs) {\n\t\tsprites.hasJpg = true;\n\t\tawait createSpritesheetFromImages(spritesheetId, sprites, jpgs, jpgPath);\n\t}\n\t\n\t// there seems to be some timing issues - give a moment to \n\t// settle down before compressing - ideally, we can just\n\t// pipe results eventually\n\tawait timeout(2000);\n\n\t// verify the resource directory\n\tconst tmpId = _.snakeCase(spritesheetId);\n\tconst resourceDir = `dist${path.dirname(basePath).substr(OUTPUT_DIR.length)}`;\n\tconst tmpDir = `${resourceDir}/_${tmpId}`;\n\tawait fs.mkdirp(resourceDir);\n\n\t// compress resources\n\treturn new Promise((resolve, reject) => {\n\t\tcompressImages(\n\t\t\t`${tmpDir}/*.{jpg,png}`, // input\n\t\t\t`${resourceDir}/`, // output\n\t\t\t{\n\t\t\t\tcompress_force: true,\n\t\t\t\tstatistic: true,\n\t\t\t\tautoupdate: false,\n\t\t\t},\n\t\t\tfalse, // ??\n\t\t\t{ jpg: {engine: 'mozjpeg', command: JPG_COMPRESSION_ARGS}},\n\t\t\t{ png: {engine: 'pngquant', command: PNG_COMPRESSION_ARGS}},\n\t\t\t{svg: {engine: false, command: false}},\n\t\t\t{gif: {engine: false, command: false}},\n\n\t\t\t// finalize\n\t\t\tasync function(error, completed, statistic){\n\n\t\t\t\t// remove the temporary generation dir\n\t\t\t\tfs.remove(tmpDir);\n\n\t\t\t\t// check for errors\n\t\t\t\tif (error) {\n\t\t\t\t\tconsole.error(`Compression failure for ${resourceDir}`);\n\t\t\t\t\tconsole.error(error);\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t\t// compressed as expected\n\t\t\t\telse resolve();\n\t\t\t});\n\t\t});\n}\n\n// updates the spritesheet with image names\nasync function createSpritesheetFromImages(spritesheetId, sprites, images, saveTo) {\n\n\t// convert to a spritesheet\n\tconst src = _.map(images, item => item.path);\n\tconst { image, coordinates } = await asyncCallback(Spritesmith.run, { src });\n\tconst ext = path.extname(saveTo).substr(1);\n\t\n\t// simplify the output format\n\tfor (const file in coordinates) {\n\t\tconst bounds = coordinates[file];\n\t\tconst name = fileToKey(file);\n\n\t\t// if this name already exists, then there's a conflict in\n\t\t// names and needs to be stopped\n\t\tif (sprites[name]) {\n\t\t\tthrow new Error(`Conflicting sprite name: ${name} in ${spritesheetId}`)\n\t\t}\n\n\t\tsprites[name] = [bounds.x, bounds.y, bounds.width, bounds.height, ext];\n\t}\n\n\t// write the image\n\tconst tmpId = _.snakeCase(spritesheetId);\n\tconst dir = `${path.dirname(saveTo)}/_${tmpId}`;\n\tconst target = `${dir}/${path.basename(saveTo)}`\n\tawait fs.mkdirp(dir);\n\tawait fs.writeFile(target, image, 'binary');\n}\n\n// check the last modified time for a file, if it exists\nfunction getModifiedTime(path) {\n\ttry { return fs.statSync(path).mtime || 0; }\n\tcatch (ex) { return 0 }\n}\n","import _ from 'lodash';\nimport fs from 'fs-extra';\nimport path from 'path';\n\nimport { getDirectoryContents, readYml, fileToKey } from './utils.js';\nimport { generateSpritesheet } from './generate-spritesheet.js';\nimport paths from '../paths.js';\n\n/** generates a resource item */\nexport default async function generateResource(root, node, id, options) {\n\tconst { INPUT_DIR } = paths;\n\tconst hasSubdir = !!options.subdir;\n\tconst subdir = hasSubdir ? `${options.subdir}/` : '';\n\tconst pathId = `${subdir}${id}`;\n\tconst dir = path.resolve(`${INPUT_DIR}/${pathId}`);\n\tconst nodeId = options.nodeId || id;\n\t\n\t// if it's missing, don't bother\n\t// there will be a separate process to remove\n\t// files that no longer exist so cleanup is not required\n\tconst exists = await fs.exists(dir);\n\tif (!exists) return;\n\n\t// gather file contents\n\tconsole.log('[generating]', pathId);\n\tconst { images, markup } = await getDirectoryContents(dir, options);\n\n\t// copy all YML data\n\tconst data = { };\n\tfor (const item of markup) {\n\t\tconst contents = await readYml(item.path);\n\t\tconst key = fileToKey(item.path);\n\n\t\t// assign the data -- for a default index file, just assign the data\n\t\tif (key === 'index') Object.assign(data, contents);\n\t\telse data[key] = contents;\n\t}\n\n\t// save the data, if any\n\tif (_.some(data)) {\n\t\tnode[nodeId] = data;\n\t}\n\n\t// generate the spritesheet, if any\n\tif (_.some(images)) {\n\t\tconst { spritesheetName } = options;\n\t\tawait generateSpritesheet(root.spritesheets, id, spritesheetName, subdir, images);\n\t}\n\n}\n","import path from 'path';\nimport fs from 'fs-extra';\n\n/** handles checking a directory for content */\nexport default async function scanDirectory(source, options, action) {\n\n\t// doesn't exist yet\n\tconst exists = await fs.exists(source);\n\tif (!exists) return;\n\n\t// gather all sub folders\n\tconst dirs = await fs.readdir(source);\n\tfor (const dir of dirs) {\n\n\t\t// make sure it's not a hidden file and\n\t\t// is actually a directory\n\t\tconst location = path.resolve(`${source}/${dir}`);\n\t\tconst stat = await fs.stat(location);\n\t\tconst isHidden = dir[0] === '.';\n\t\tconst isDirectory = stat.isDirectory();\n\t\tconst allowType = isDirectory || (!isDirectory && options.allowFiles);\n\t\tconst allowHidden = !isHidden || (isHidden && options.allowHidden);\n\n\t\t// continue with this resource\n\t\tif (allowType && allowHidden) \n\t\t\tawait action(dir, location);\n\t}\n\n}","import path from 'path';\nimport paths from '../paths.js';\nimport generateResource from './generate-resource.js';\nimport scanDirectory from './scan-directory.js';\n\n/** generates a resource from each item in a directory */\nexport default async function generateResourcesFromDirectory(root, node, id, options) {\n\tconst { INPUT_DIR } = paths;\n\tconst source = path.resolve(`${INPUT_DIR}/${id}`);\n\t\n\t// if the node is missing, create it\n\tif (!node) {\n\t\tnode = { };\n\t\troot[id] = node;\n\t}\n\n\t// process all diles in a directory\n\tawait scanDirectory(source, { }, async dir => {\n\t\tawait generateResource(root, node, dir, { nodeId: dir, subdir: id });\n\t});\n}","\nimport _ from 'lodash';\nimport fs from 'fs-extra';\nimport path from 'path';\nimport getMP3Duration from 'get-mp3-duration';\nimport fluent from 'fluent-ffmpeg';\n\nimport { fileToKey } from './utils.js';\nimport paths from '../paths.js';\nimport getMp3Duration from 'get-mp3-duration';\n\n// create sound sprites from \nexport default async function generateSoundSprites(root) {\n\tconst { INPUT_DIR, OUTPUT_DIR } = paths;\n\tconst dir = 'sounds';\n\tconst input = path.resolve(INPUT_DIR, dir)\n\n\t// collect possible sprites\n\tconst sprites = [ ];\n\tconst entries = await fs.readdir(input);\n\tfor (const entry of entries) {\n\t\t\n\t\t// filter out hidden files\n\t\tif (/^\\./i.test(entry)) continue;\n\t\t\n\t\t// check the file into\n\t\tconst file = path.resolve(input, entry);\n\t\tconst stat = await fs.stat(file);\n\n\t\t// if is an mp3 file\n\t\tif (isMP3(file)) {\n\t\t\tconst buffer = await fs.readFile(file);\n\t\t\tconst duration = getMP3Duration(buffer);\n\t\t\tsprites.push({ file, duration });\n\t\t}\n\t\t// is a directory -- check for more MP3 Files\n\t\telse if (stat.isDirectory()) {\n\t\t\tawait copyMP3s(`${dir}/${entry}`);\n\t\t}\n\n\t}\n\n\t// gather the paths to concat\n\tconst files = [ ];\n\tconst silence = path.resolve(INPUT_DIR, 'silence.mp3');\n\tconst silenceBuffer = await fs.readFile(silence);\n\tconst spacer = getMp3Duration(silenceBuffer);\n\n\t// calculate the sprite info\n\tlet duration = 0;\n\troot.sounds = { };\n\tfor (const sprite of sprites) { \n\n\t\t// save the file to use\n\t\tfiles.push(sprite.file, silence);\n\n\t\t// get the key\n\t\tconst key = fileToKey(sprite.file);\n\t\troot.sounds[key] = [ duration, sprite.duration ];\n\n\t\t// update the duration - include an\n\t\t// extra 100 ms for silence between sounds\n\t\tduration += sprite.duration + spacer;\n\t}\n\n\t// merge the files\n\tconst output = path.resolve(OUTPUT_DIR, `sounds/common.mp3`);\n\tawait mergeMP3FilesToOutput(output, files);\n\tconsole.log(`[audio] ${dir}/common.mp3`);\n}\n\n\n// copy and compress each MP3 in a directory\nasync function copyMP3s(dir) {\n\tconst input = path.resolve(INPUT_DIR, dir);\n\tconst output = path.resolve(OUTPUT_DIR, dir);\n\n\tconst entries = await fs.readdir(input);\n\tfor (const entry of entries) {\n\n\t\t// ensure it's an mp3\n\t\tif (!isMP3(entry)) continue;\n\n\t\t// make the directory, if needed\n\t\tconst exists = await fs.exists(output);\n\t\tif (!exists) await fs.mkdirp(output);\n\n\t\t// copy the file\n\t\tconst source = path.resolve(input, entry);\n\t\tconst target = path.resolve(output, entry);\n\n\t\t// copy the compressed version\n\t\tawait copyAndCompressMP3(source, target);\n\t\tconsole.log(`[audio] ${dir}/${entry}`);\n\t}\n}\n\n// handles copying individual MP3 files\nasync function copyAndCompressMP3(input, output) {\n\treturn new Promise((resolve, reject) => {\n\t\tfluent()\n\n\t\t\t// get the file top copy\n\t\t\t.input(input)\n\t\t\n\t\t\t// handle events\n\t\t\t.on('end', resolve)\n\t\t\t.on('error', reject)\n\n\t\t\t// configure audio\n\t\t\t.audioBitrate(48)\n\t\t\t.audioChannels(1)\n\n\t\t\t// then merge it\n\t\t\t.mergeToFile(output);\n\t});\n}\n\n// merge all mp3 files into a single file\nasync function mergeMP3FilesToOutput(output, paths) {\n\treturn new Promise((resolve, reject) => {\n\t\t\n\t\t// prepare the command\n\t\tconst concat = fluent();\n\t\t\t\n\t\t// add all files\n\t\tfor (const path of paths)\n\t\t\tconcat.input(path);\n\n\t\t// export\n\t\tconcat\n\t\t\t// handle events\n\t\t\t.on('end', resolve)\n\t\t\t.on('error', reject)\n\n\t\t\t// configure audio\n\t\t\t.audioBitrate(48)\n\t\t\t.audioChannels(1)\n\n\t\t\t// then merge it\n\t\t\t.mergeToFile(output);\n\t});\n}\n\n// checks if a file is an MP3 file\nfunction isMP3(file) {\n\tconst base = path.basename(file);\n\treturn /\\.mp3$/i.test(base);\n}\n","import fs from 'fs-extra';\nimport paths from '../paths.js';\nimport xml2js from 'xml2js';\nimport omgsvg from 'omgsvg/omgsvg.js';\nimport Bezier from 'bezier-js';\n\n\n/** uses the race-progress.svg file to calculate  */\nexport async function compileProgressPath() {\n\tconst { width, height, offsetX, offsetY, svg } = await extractFile();\n\tconst { points, distance } = extractPoints(svg);\n\treturn createProgress(points, distance, offsetY, height);\n}\n\n\n// reads in the svg data\nasync function extractFile() {\n\tconst { INPUT_DIR } = paths;\n\tconst source = await fs.readFile(`${INPUT_DIR}/race-progress.svg`);\n\tconst markup = source.toString();\n\tconst doc = await xml2js.parseStringPromise(markup);\n\n\t// search for content\n\tlet rect;\n\tlet path;\n\tfor (const id in doc.svg) {\n\t\tif (id === 'rect') rect = doc.svg[id];\n\t\telse if (id === 'path') path = doc.svg[id];\n\t}\n\n\t// gather data\n\t// library has arrays for each type and dollar sign\n\t// to access attributes\n\tconst offsetX = 0 | rect[0].$.x;\n\tconst offsetY = 0 | rect[0].$.y;\n\tconst width = 0 | rect[0].$.width;\n\tconst height = 0 | rect[0].$.height;\n\tconst svg = path[0].$.d;\n\n\treturn { width, height, offsetX, offsetY, svg };\n}\n\n\n// reads the svg path data points\nfunction extractPoints(svg) {\n\n\t// overall path definition\n\tconst points = [ ];\n\n\t// parse this path\n\tlet distance = 0;\n\tconst parsed = new omgsvg.SVGPathParser(svg);\n\twhile (parsed.seek_next_cmd()) {\n\t\tconst args = parsed.parse_cur_args();\n\t\tconst index = points.length;\n\n\t\t// this is the first point - nothing\n\t\t// needs to be done other than add it\n\t\tif (index === 0) {\n\t\t\tconst [ x, y ] = args;\n\t\t\tpoints.push({ isStart: true, points: args, x, y, dist: 0 });\n\t\t}\n\t\t// this is a line - get the total distance\n\t\telse if (args.length === 2) {\n\t\t\tconst previous = points[index - 1];\n\t\t\tconst [ x, y ] = args;\n\t\t\tconst dist = Math.hypot(previous.x - x, previous.y - y);\n\n\t\t\t// update the total length\n\t\t\tdistance += dist;\n\n\t\t\t// replace this command\n\t\t\tpoints.push({ isLine: true, points: args, x, y, dist });\n\t\t}\n\t\t// this uses 6 command points and is a bezier curve\n\t\telse if (args.length === 6) {\n\t\t\tconst previous = points[index - 1];\n\t\t\tconst [ cx1, cy1, cx2, cy2, x, y ] = args;\n\t\t\tconst curve = new Bezier(previous.x, previous.y, cx1, cy1, cx2, cy2, x, y);\n\t\t\tconst dist = curve.length();\n\n\t\t\t// update the total length\n\t\t\t// end = start + dist; \n\t\t\tdistance += dist;\n\n\t\t\t// replace this command\n\t\t\tpoints.push({ isBezier: true, points: args, x, y, dist, curve });\n\t\t}\n\t\t// no quadratic curves\n\t\telse if (args.length === 4) {\n\t\t\tthrow 'Quadradic curves are not supported';\n\t\t}\n\t}\n\n\treturn { points, distance };\n}\n\n\n// generate the progress from the svg path\nfunction createProgress(points, distance, offsetY, height) {\n\tconst progress = [ ];\n\n\t// normalizes each y-axis point as a percentage, so the lower\n\t// the y value is actually more progress\n\tconst normalizePoint = y => {\n\t\t// round the number to two decimal places\n\t\treturn (0 | (1 - ((y - offsetY) / height)) * 100) / 100;\n\t};\n\n\t// with the known length, calculate the points along each\n\t// path to account for their space. This also \n\tlet index = 1;\n\tlet max = 0;\n\tconst scale = 1;\n\tconst samples = 100 * scale;\n\n\t// calculate the preferred number of samples for the progress\n\twhile (max < samples) {\n\t\tconst current = points[index];\n\t\tconst segment = Math.round(samples * (current.dist / distance));\n\n\t\t// get the percentage distance\n\t\tmax += segment;\n\n\t\t// sample the required points for a curve\n\t\t// and save all y/axis values\n\t\tif (current.isBezier) {\n\t\t\tconst lut = current.curve.getLUT(segment);\n\t\t\tfor (const point of lut) {\n\t\t\t\tconst t = normalizePoint(point.y)\n\t\t\t\tprogress.push(t);\n\t\t\t}\n\t\t}\n\t\t// for a line, just interpolate the y position\n\t\telse if (current.isLine) {\n\t\t\tconst previous = points[index - 1];\n\t\t\tfor (let i = 0; i < segment; i++) {\n\t\t\t\tconst y = previous.y + ((current.y - previous.y) * (i / segment));\n\t\t\t\tconst t = normalizePoint(y);\n\t\t\t\tprogress.push(t);\n\t\t\t}\n\t\t}\n\t\t// shouldn't happen, but if the point type\n\t\t// is unexpected, complain about it\n\t\telse {\n\t\t\tthrow 'Unexpected point type in path'\n\t\t}\n\n\t\t// continue forward\n\t\tindex++;\n\t}\n\n\treturn progress;\n}","\n// !!!\n// NOTE: something about this version of Babel requires that\n// imported files are ended with .js or .mjs - if you get an\n// error about ERR_MODULE_NOT_FOUND then check that first\n\nimport _ from 'lodash';\nimport fs from 'fs-extra';\nimport path from 'path';\n\n// resource generation approaches\nimport * as cache from './cache.js';\nimport generateResource from './generate-resource.js';\nimport generateResourcesFromDirectory from './generate-resource-from-dir.js';\nimport generateSoundsSpritesheet from './generate-sounds-spritesheet.js';\nimport scanDirectory from './scan-directory.js';\n\nimport paths from '../paths.js';\nimport { compileProgressPath } from './compile-progress-path.js';\n\n// check if debugging mode should be used\nconst DEBUG = !!~process.argv.indexOf('--debug');\n\n/** handles compiling all resources in the repo folder */\nasync function compile() {\n\tconst { INPUT_DIR, OUTPUT_DIR } = paths;\n\tconst exported = path.resolve(`${OUTPUT_DIR}/export.json`);\n\n\t// load the previous document into the cache\n\tawait cache.load(exported);\n\n\t// ensure directories\n\tawait fs.mkdirp(OUTPUT_DIR);\n\n\t// TODO: restore data\n\t// check for changes\n\tconst data = { };\n\tif (!('spritesheets' in data)) data.spritesheets = { };\n\tif (!('tracks' in data)) data.tracks = { };\n\n\t// create the sounds, if needed\n\tawait generateSoundsSpritesheet(data);\n\n\t// start generating files\n\tawait generateResource(data, data, 'particles', { });\n\tawait generateResource(data, data, 'images', { });\n\tawait generateResource(data, data, 'animations', { });\n\tawait generateResource(data, data, 'emitters', { });\n\tawait generateResource(data, data, 'crowd', { });\n\t\n\t// generate resources that have sub files\n\tawait generateResourcesFromDirectory(data, data.trails, 'trails', { });\n\tawait generateResourcesFromDirectory(data, data.intro, 'intros', { });\n\tawait generateResourcesFromDirectory(data, data.nitros, 'nitros', { });\n\tawait generateResourcesFromDirectory(data, data.cars, 'cars', { });\n\tawait generateResourcesFromDirectory(data, data.namecards, 'namecards', { });\n\tawait generateResourcesFromDirectory(data, data.extras, 'extras', { });\n\n\t// tracks have variations so each directory should\n\t// be scanned to see all available types\n\tawait scanDirectory(`${INPUT_DIR}/tracks`, { }, async (trackName, fullTrackDir) => {\n\n\t\t// save the track node\n\t\tdata.tracks[trackName] = { };\n\n\t\t// create all variations\n\t\tawait scanDirectory(fullTrackDir, { }, async variant => {\n\t\t\tdata.tracks[trackName][variant] = { };\n\n\t\t\t// generate a resource per variation\n\t\t\tawait generateResource(data, data.tracks[trackName], variant, { \n\t\t\t\tsubdir: `tracks/${trackName}`\n\t\t\t});\n\t\t});\n\t});\n\n\t// compile the path progress helper\n\tdata.progress = await compileProgressPath();\n\n\t// include animation data\n\tconst animations = await fs.readFile(`${INPUT_DIR}/crowd/animations.json`);\n\tdata.crowd = JSON.parse(animations.toString());\n\n\t// save the completed file\n\tconst generated = JSON.stringify(data, null, DEBUG ? 2 : null);\n\tconsole.log(`[export] ${exported}`);\n\tawait fs.writeFile(exported, generated);\n}\n\n\n// kick off the compile\n// (async () => await compile())();"]}