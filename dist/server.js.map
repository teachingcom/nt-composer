{"version":3,"sources":["../compile/cache.js","../compile/paths.js","../compile/utils.js","../compile/compression.json","../compile/generate-spritesheet.js","../compile/generate-resource.js","../compile/scan-directory.js","../compile/generate-resource-from-dir.js","../compile/generate-sounds-spritesheet.js","../compile/compile-progress-path.js","../compile/compile.js","../compile/index.js","server.js"],"names":["data","load","path","content","fs","readFile","parsed","JSON","parse","toString","Object","assign","ex","paths","exec","script","INPUT_DIR","OUTPUT_DIR","process","argv","resolve","replacePaths","inputDir","outputDir","readYml","exists","contents","yml","console","error","getDirectoryContents","dir","markup","images","files","readdir","file","source","stat","isDirectory","lastModified","mtime","ext","extname","ref","indexOf","push","asyncCallback","action","args","Promise","reject","err","res","fileToKey","_","snakeCase","basename","timeout","time","setTimeout","module","exports","jpeg_quality","png_max_palette_colors","COMPRESSION_PARAMS","JPG_COMPRESSION_ARGS","PNG_COMPRESSION_ARGS","generateSpritesheet","spritesheets","nodeId","spritesheetName","subdir","spritesheetId","basePath","pngPath","jpgPath","jpgs","filter","item","test","pngs","hasPngs","some","hasJpgs","generatedTimes","getModifiedTime","lastGenerated","expired","Math","min","apply","isNaN","existing","get","cache","log","sprites","hasPng","createSpritesheetFromImages","hasJpg","tmpId","resourceDir","dirname","substr","length","tmpDir","mkdirp","compress_force","statistic","autoupdate","jpg","engine","command","png","svg","gif","completed","remove","saveTo","src","map","image","coordinates","Spritesmith","run","bounds","name","Error","x","y","width","height","target","writeFile","statSync","generateResource","root","node","id","options","pathId","key","scanDirectory","dirs","location","isHidden","allowType","allowFiles","allowHidden","generateResourcesFromDirectory","generateSoundSprites","input","entries","entry","isMP3","buffer","duration","copyMP3s","silence","silenceBuffer","spacer","sounds","sprite","output","mergeMP3FilesToOutput","copyAndCompressMP3","on","audioBitrate","audioChannels","mergeToFile","concat","base","compileProgressPath","offsetX","offsetY","extractFile","points","distance","extractPoints","createProgress","doc","xml2js","parseStringPromise","rect","$","d","omgsvg","SVGPathParser","seek_next_cmd","parse_cur_args","index","isStart","dist","previous","hypot","isLine","cx1","cy1","cx2","cy2","curve","Bezier","isBezier","progress","normalizePoint","max","current","segment","round","lut","getLUT","point","t","i","DEBUG","compile","exported","tracks","trails","intro","nitros","cars","namecards","extras","trackName","fullTrackDir","variant","animations","crowd","generated","stringify","utils","allUtils","CONFIG","ROOT","ws","waitingForAssets","pendingRefresh","connections","serve","config","bundler","port","dev","Bundler","outDir","sourceMaps","app","configureWebSockets","use","express","static","watch","queueCompileAssets","middleware","waitForAssets","listen","Server","socket","splice","clearTimeout","compileAssets","notifyConnections","message","send"],"mappings":"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","file":"server.js","sourceRoot":"../preview","sourcesContent":["import fs from 'fs-extra';\n\n/** the previous version of the file */\nexport const data = { };\n\n// tries to load the previous document, if any\nexport async function load(path) {\n\ttry {\n\t\tconst content = await fs.readFile(path);\n\t\tconst parsed = JSON.parse(content.toString());\n\t\tObject.assign(data, parsed);\n\t}\n\t// wasn't able to restore the file\n\tcatch (ex) { }\n}\n","import path from 'path';\nconst [ exec, script, INPUT_DIR, OUTPUT_DIR ] = (process.argv || [ ]);\n\n// get the root path\nconst paths = { \n\tOUTPUT_DIR: path.resolve(INPUT_DIR || ''),\n\tINPUT_DIR: path.resolve(OUTPUT_DIR || ''),\n};\n\nexport function replacePaths(inputDir, outputDir) {\n\tpaths.INPUT_DIR = inputDir;\n\tpaths.OUTPUT_DIR = outputDir;\n}\n\nexport default paths;","import _ from 'lodash';\nimport fs from 'fs-extra';\nimport path from 'path';\nimport yml from 'js-yaml';\n\n/** reads a YML file */\nexport async function readYml(path) {\n\n\t// make sure this exists\n\tconst exists = await fs.exists(path);\n\tif (!exists) return null;\n\n\t// try and read the content\n\ttry {\n\t\tconst contents = await fs.readFile(path);\n\t\treturn yml.load(contents.toString());\n\t}\n\tcatch (ex) {\n\t\tconsole.error(`YAML Error in ${path}`);\n\t\tthrow ex;\n\t}\n}\n\n/** gather up contents for a directory */\nexport async function getDirectoryContents(dir) {\n\tlet markup = [ ];\n\tlet images = [ ];\n\n\t// get modified times for each file\n\tconst files = await fs.readdir(dir);\n\tfor (let file of files) {\n\n\t\t// get the source\n\t\tconst source = path.resolve(`${dir}/${file}`);\n\t\tconst stat = await fs.stat(source);\n\t\tconst isDirectory = stat.isDirectory();\n\t\tconst lastModified = +stat.mtime;\n\t\tconst ext = path.extname(file);\n\t\t\n\t\t// skip directories and hidden files\n\t\tif (isDirectory || file[0] === '.') continue;\n\n\t\t// add to the correct group\n\t\tconst ref = !!~['.yml', '.yaml'].indexOf(ext) ? markup\n\t\t\t: !!~['.jpg', '.jpeg', '.png'].indexOf(ext) ? images\n\t\t\t: null;\n\n\t\t// create the record\n\t\tif (ref) ref.push({ path: source, lastModified });\n\t}\n\n\treturn { markup, images };\n}\n\n/** perfoms a callback as an async call */\nexport async function asyncCallback(action, ...args) {\n\treturn new Promise((resolve, reject) => {\n\t\taction(...args, (err, ...res) => {\n\t\t\tif (err) reject(err);\n\t\t\telse resolve(...res);\n\t\t});\n\t});\n}\n\n/** generates a key from a file name or path */\nexport function fileToKey(file) {\n\treturn _.snakeCase(path.basename(file, path.extname(file)))\n}\n\n/** waits a specified time */\nexport async function timeout(time) {\n\treturn new Promise(resolve => {\n\t\tsetTimeout(resolve, time);\n\t});\n}","module.exports={jpeg_quality:80,png_max_palette_colors:128};","import _ from 'lodash';\nimport fs from 'fs-extra';\nimport path from 'path';\nimport Spritesmith from 'spritesmith';\nimport compressImages from 'compress-images';\n\nimport COMPRESSION_PARAMS from './compression.json';\nimport { fileToKey, asyncCallback, timeout } from './utils.js';\nimport paths from './paths.js';\nimport * as cache from './cache.js';\n\n// compression args\nconst { jpeg_quality, png_max_palette_colors } = COMPRESSION_PARAMS;\nconst JPG_COMPRESSION_ARGS = ['-quality', jpeg_quality];\nconst PNG_COMPRESSION_ARGS = [png_max_palette_colors, '-f', '--strip', '--skip-if-larger'];\n\nexport async function generateSpritesheet(spritesheets, nodeId, spritesheetName, subdir, images) {\n\tconst { OUTPUT_DIR } = paths;\n\tconst spritesheetId = `${subdir}${spritesheetName || nodeId}`;\n\n\t// get the possible paths\n\tconst basePath = path.resolve(`${OUTPUT_DIR}/${spritesheetId}`);\n\tconst pngPath = `${basePath}.png`;\n\tconst jpgPath = `${basePath}.jpg`;\n\n\t// check for certain type\n\tconst jpgs = _.filter(images, item => /jpe?g$/i.test(item.path));\n\tconst pngs = _.filter(images, item => /png$/i.test(item.path));\n\n\t// check if \n\tconst hasPngs = _.some(pngs);\n\tconst hasJpgs = _.some(jpgs);\n\n\t// check each time, but only if the image type is expected\n\tconst generatedTimes = [ ];\n\tif (hasPngs) generatedTimes.push(getModifiedTime(pngPath));\n\tif (hasJpgs) generatedTimes.push(getModifiedTime(jpgPath));\n\tlet lastGenerated = Math.min.apply(Math, generatedTimes);\n\tif (isNaN(lastGenerated)) lastGenerated = 0;\n\n\t// if all of the images have a lower write time\n\t// than the sprite sheet then we don't need to compile it again\n\tlet expired;\n\tfor (const item of images) {\n\t\texpired = expired || item.lastModified > lastGenerated;\n\t}\n\n\t// check and make sure the prior data is available\n\tconst existing = _.get(cache.data, 'spritesheets', { })[spritesheetId];\n\t\n\t// if it's not expired and we have the old info then\n\t// we can just reuse it\n\tif (!expired && existing) {\n\t\tspritesheets[spritesheetId] = existing;\n\t\treturn;\n\t}\n\n\t// notify of params\n\tconsole.log(`Compression Params\n\tjpeg_quality           : ${jpeg_quality}\n\tpng_max_palette_colors : ${png_max_palette_colors}`);\n\n\t// save the new spritesheet location\n\tconst sprites = spritesheets[spritesheetId] = { };\n\n\t// generate PNGs\n\tif (hasPngs) {\n\t\tsprites.hasPng = true;\n\t\tawait createSpritesheetFromImages(spritesheetId, sprites, pngs, pngPath);\n\t}\n\t\n\t// generate JPGs\n\tif (hasJpgs) {\n\t\tsprites.hasJpg = true;\n\t\tawait createSpritesheetFromImages(spritesheetId, sprites, jpgs, jpgPath);\n\t}\n\t\n\t// there seems to be some timing issues - give a moment to \n\t// settle down before compressing - ideally, we can just\n\t// pipe results eventually\n\tawait timeout(2000);\n\n\t// verify the resource directory\n\tconst tmpId = _.snakeCase(spritesheetId);\n\tconst resourceDir = `dist${path.dirname(basePath).substr(OUTPUT_DIR.length)}`;\n\tconst tmpDir = `${resourceDir}/_${tmpId}`;\n\tawait fs.mkdirp(resourceDir);\n\n\t// compress resources\n\treturn new Promise((resolve, reject) => {\n\t\tcompressImages(\n\t\t\t`${tmpDir}/*.{jpg,png}`, // input\n\t\t\t`${resourceDir}/`, // output\n\t\t\t{\n\t\t\t\tcompress_force: true,\n\t\t\t\tstatistic: true,\n\t\t\t\tautoupdate: false,\n\t\t\t},\n\t\t\tfalse, // ??\n\t\t\t{ jpg: {engine: 'mozjpeg', command: JPG_COMPRESSION_ARGS}},\n\t\t\t{ png: {engine: 'pngquant', command: PNG_COMPRESSION_ARGS}},\n\t\t\t{svg: {engine: false, command: false}},\n\t\t\t{gif: {engine: false, command: false}},\n\n\t\t\t// finalize\n\t\t\tasync function(error, completed, statistic){\n\n\t\t\t\t// remove the temporary generation dir\n\t\t\t\tfs.remove(tmpDir);\n\n\t\t\t\t// check for errors\n\t\t\t\tif (error) {\n\t\t\t\t\tconsole.error(`Compression failure for ${resourceDir}`);\n\t\t\t\t\tconsole.error(error);\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t\t// compressed as expected\n\t\t\t\telse resolve();\n\t\t\t});\n\t\t});\n}\n\n// updates the spritesheet with image names\nasync function createSpritesheetFromImages(spritesheetId, sprites, images, saveTo) {\n\n\t// convert to a spritesheet\n\tconst src = _.map(images, item => item.path);\n\tconst { image, coordinates } = await asyncCallback(Spritesmith.run, { src });\n\tconst ext = path.extname(saveTo).substr(1);\n\t\n\t// simplify the output format\n\tfor (const file in coordinates) {\n\t\tconst bounds = coordinates[file];\n\t\tconst name = fileToKey(file);\n\n\t\t// if this name already exists, then there's a conflict in\n\t\t// names and needs to be stopped\n\t\tif (sprites[name]) {\n\t\t\tthrow new Error(`Conflicting sprite name: ${name} in ${spritesheetId}`)\n\t\t}\n\n\t\tsprites[name] = [bounds.x, bounds.y, bounds.width, bounds.height, ext];\n\t}\n\n\t// write the image\n\tconst tmpId = _.snakeCase(spritesheetId);\n\tconst dir = `${path.dirname(saveTo)}/_${tmpId}`;\n\tconst target = `${dir}/${path.basename(saveTo)}`\n\tawait fs.mkdirp(dir);\n\tawait fs.writeFile(target, image, 'binary');\n}\n\n// check the last modified time for a file, if it exists\nfunction getModifiedTime(path) {\n\ttry { return fs.statSync(path).mtime || 0; }\n\tcatch (ex) { return 0 }\n}\n","import _ from 'lodash';\nimport fs from 'fs-extra';\nimport path from 'path';\n\nimport { getDirectoryContents, readYml, fileToKey } from './utils.js';\nimport { generateSpritesheet } from './generate-spritesheet.js';\nimport paths from './paths.js';\n\n/** generates a resource item */\nexport default async function generateResource(root, node, id, options) {\n\tconst { INPUT_DIR } = paths;\n\tconst hasSubdir = !!options.subdir;\n\tconst subdir = hasSubdir ? `${options.subdir}/` : '';\n\tconst pathId = `${subdir}${id}`;\n\tconst dir = path.resolve(`${INPUT_DIR}/${pathId}`);\n\tconst nodeId = options.nodeId || id;\n\t\n\t// if it's missing, don't bother\n\t// there will be a separate process to remove\n\t// files that no longer exist so cleanup is not required\n\tconst exists = await fs.exists(dir);\n\tif (!exists) return;\n\n\t// gather file contents\n\tconsole.log('[generating]', pathId);\n\tconst { images, markup } = await getDirectoryContents(dir, options);\n\n\t// copy all YML data\n\tconst data = { };\n\tfor (const item of markup) {\n\t\tconst contents = await readYml(item.path);\n\t\tconst key = fileToKey(item.path);\n\n\t\t// assign the data -- for a default index file, just assign the data\n\t\tif (key === 'index') Object.assign(data, contents);\n\t\telse data[key] = contents;\n\t}\n\n\t// save the data, if any\n\tif (_.some(data)) {\n\t\tnode[nodeId] = data;\n\t}\n\n\t// generate the spritesheet, if any\n\tif (_.some(images)) {\n\t\tconst { spritesheetName } = options;\n\t\tawait generateSpritesheet(root.spritesheets, id, spritesheetName, subdir, images);\n\t}\n\n}\n","import path from 'path';\nimport fs from 'fs-extra';\n\n/** handles checking a directory for content */\nexport default async function scanDirectory(source, options, action) {\n\n\t// doesn't exist yet\n\tconst exists = await fs.exists(source);\n\tif (!exists) return;\n\n\t// gather all sub folders\n\tconst dirs = await fs.readdir(source);\n\tfor (const dir of dirs) {\n\n\t\t// make sure it's not a hidden file and\n\t\t// is actually a directory\n\t\tconst location = path.resolve(`${source}/${dir}`);\n\t\tconst stat = await fs.stat(location);\n\t\tconst isHidden = dir[0] === '.';\n\t\tconst isDirectory = stat.isDirectory();\n\t\tconst allowType = isDirectory || (!isDirectory && options.allowFiles);\n\t\tconst allowHidden = !isHidden || (isHidden && options.allowHidden);\n\n\t\t// continue with this resource\n\t\tif (allowType && allowHidden) \n\t\t\tawait action(dir, location);\n\t}\n\n}","import path from 'path';\nimport paths from './paths.js';\nimport generateResource from './generate-resource.js';\nimport scanDirectory from './scan-directory.js';\n\n/** generates a resource from each item in a directory */\nexport default async function generateResourcesFromDirectory(root, node, id, options) {\n\tconst { INPUT_DIR } = paths;\n\tconst source = path.resolve(`${INPUT_DIR}/${id}`);\n\t\n\t// if the node is missing, create it\n\tif (!node) {\n\t\tnode = { };\n\t\troot[id] = node;\n\t}\n\n\t// process all diles in a directory\n\tawait scanDirectory(source, { }, async dir => {\n\t\tawait generateResource(root, node, dir, { nodeId: dir, subdir: id });\n\t});\n}","\nimport _ from 'lodash';\nimport fs from 'fs-extra';\nimport path from 'path';\nimport getMP3Duration from 'get-mp3-duration';\nimport fluent from 'fluent-ffmpeg';\n\nimport { fileToKey } from './utils.js';\nimport paths from './paths.js';\nimport getMp3Duration from 'get-mp3-duration';\n\n// create sound sprites from \nexport default async function generateSoundSprites(root) {\n\tconst { INPUT_DIR, OUTPUT_DIR } = paths;\n\tconst dir = 'sounds';\n\tconst input = path.resolve(INPUT_DIR, dir)\n\n\t// collect possible sprites\n\tconst sprites = [ ];\n\tconst entries = await fs.readdir(input);\n\tfor (const entry of entries) {\n\t\t\n\t\t// filter out hidden files\n\t\tif (/^\\./i.test(entry)) continue;\n\t\t\n\t\t// check the file into\n\t\tconst file = path.resolve(input, entry);\n\t\tconst stat = await fs.stat(file);\n\n\t\t// if is an mp3 file\n\t\tif (isMP3(file)) {\n\t\t\tconst buffer = await fs.readFile(file);\n\t\t\tconst duration = getMP3Duration(buffer);\n\t\t\tsprites.push({ file, duration });\n\t\t}\n\t\t// is a directory -- check for more MP3 Files\n\t\telse if (stat.isDirectory()) {\n\t\t\tawait copyMP3s(`${dir}/${entry}`);\n\t\t}\n\n\t}\n\n\t// gather the paths to concat\n\tconst files = [ ];\n\tconst silence = path.resolve(INPUT_DIR, 'silence.mp3');\n\tconst silenceBuffer = await fs.readFile(silence);\n\tconst spacer = getMp3Duration(silenceBuffer);\n\n\t// calculate the sprite info\n\tlet duration = 0;\n\troot.sounds = { };\n\tfor (const sprite of sprites) { \n\n\t\t// save the file to use\n\t\tfiles.push(sprite.file, silence);\n\n\t\t// get the key\n\t\tconst key = fileToKey(sprite.file);\n\t\troot.sounds[key] = [ duration, sprite.duration ];\n\n\t\t// update the duration - include an\n\t\t// extra 100 ms for silence between sounds\n\t\tduration += sprite.duration + spacer;\n\t}\n\n\t// merge the files\n\tconst output = path.resolve(OUTPUT_DIR, `sounds/common.mp3`);\n\tawait mergeMP3FilesToOutput(output, files);\n\tconsole.log(`[audio] ${dir}/common.mp3`);\n}\n\n\n// copy and compress each MP3 in a directory\nasync function copyMP3s(dir) {\n\tconst { INPUT_DIR, OUTPUT_DIR } = paths;\n\tconst input = path.resolve(INPUT_DIR, dir);\n\tconst output = path.resolve(OUTPUT_DIR, dir);\n\n\tconst entries = await fs.readdir(input);\n\tfor (const entry of entries) {\n\n\t\t// ensure it's an mp3\n\t\tif (!isMP3(entry)) continue;\n\n\t\t// make the directory, if needed\n\t\tconst exists = await fs.exists(output);\n\t\tif (!exists) await fs.mkdirp(output);\n\n\t\t// copy the file\n\t\tconst source = path.resolve(input, entry);\n\t\tconst target = path.resolve(output, entry);\n\n\t\t// copy the compressed version\n\t\tawait copyAndCompressMP3(source, target);\n\t\tconsole.log(`[audio] ${dir}/${entry}`);\n\t}\n}\n\n// handles copying individual MP3 files\nasync function copyAndCompressMP3(input, output) {\n\treturn new Promise((resolve, reject) => {\n\t\tfluent()\n\n\t\t\t// get the file top copy\n\t\t\t.input(input)\n\t\t\n\t\t\t// handle events\n\t\t\t.on('end', resolve)\n\t\t\t.on('error', reject)\n\n\t\t\t// configure audio\n\t\t\t.audioBitrate(48)\n\t\t\t.audioChannels(1)\n\n\t\t\t// then merge it\n\t\t\t.mergeToFile(output);\n\t});\n}\n\n// merge all mp3 files into a single file\nasync function mergeMP3FilesToOutput(output, paths) {\n\treturn new Promise((resolve, reject) => {\n\t\t\n\t\t// prepare the command\n\t\tconst concat = fluent();\n\t\t\t\n\t\t// add all files\n\t\tfor (const path of paths)\n\t\t\tconcat.input(path);\n\n\t\t// export\n\t\tconcat\n\t\t\t// handle events\n\t\t\t.on('end', resolve)\n\t\t\t.on('error', reject)\n\n\t\t\t// configure audio\n\t\t\t.audioBitrate(48)\n\t\t\t.audioChannels(1)\n\n\t\t\t// then merge it\n\t\t\t.mergeToFile(output);\n\t});\n}\n\n// checks if a file is an MP3 file\nfunction isMP3(file) {\n\tconst base = path.basename(file);\n\treturn /\\.mp3$/i.test(base);\n}\n","import fs from 'fs-extra';\nimport paths from './paths.js';\nimport xml2js from 'xml2js';\nimport omgsvg from 'omgsvg/omgsvg.js';\nimport Bezier from 'bezier-js';\n\n\n/** uses the race-progress.svg file to calculate  */\nexport async function compileProgressPath() {\n\tconst { width, height, offsetX, offsetY, svg } = await extractFile();\n\tconst { points, distance } = extractPoints(svg);\n\treturn createProgress(points, distance, offsetY, height);\n}\n\n\n// reads in the svg data\nasync function extractFile() {\n\tconst { INPUT_DIR } = paths;\n\tconst source = await fs.readFile(`${INPUT_DIR}/race-progress.svg`);\n\tconst markup = source.toString();\n\tconst doc = await xml2js.parseStringPromise(markup);\n\n\t// search for content\n\tlet rect;\n\tlet path;\n\tfor (const id in doc.svg) {\n\t\tif (id === 'rect') rect = doc.svg[id];\n\t\telse if (id === 'path') path = doc.svg[id];\n\t}\n\n\t// gather data\n\t// library has arrays for each type and dollar sign\n\t// to access attributes\n\tconst offsetX = 0 | rect[0].$.x;\n\tconst offsetY = 0 | rect[0].$.y;\n\tconst width = 0 | rect[0].$.width;\n\tconst height = 0 | rect[0].$.height;\n\tconst svg = path[0].$.d;\n\n\treturn { width, height, offsetX, offsetY, svg };\n}\n\n\n// reads the svg path data points\nfunction extractPoints(svg) {\n\n\t// overall path definition\n\tconst points = [ ];\n\n\t// parse this path\n\tlet distance = 0;\n\tconst parsed = new omgsvg.SVGPathParser(svg);\n\twhile (parsed.seek_next_cmd()) {\n\t\tconst args = parsed.parse_cur_args();\n\t\tconst index = points.length;\n\n\t\t// this is the first point - nothing\n\t\t// needs to be done other than add it\n\t\tif (index === 0) {\n\t\t\tconst [ x, y ] = args;\n\t\t\tpoints.push({ isStart: true, points: args, x, y, dist: 0 });\n\t\t}\n\t\t// this is a line - get the total distance\n\t\telse if (args.length === 2) {\n\t\t\tconst previous = points[index - 1];\n\t\t\tconst [ x, y ] = args;\n\t\t\tconst dist = Math.hypot(previous.x - x, previous.y - y);\n\n\t\t\t// update the total length\n\t\t\tdistance += dist;\n\n\t\t\t// replace this command\n\t\t\tpoints.push({ isLine: true, points: args, x, y, dist });\n\t\t}\n\t\t// this uses 6 command points and is a bezier curve\n\t\telse if (args.length === 6) {\n\t\t\tconst previous = points[index - 1];\n\t\t\tconst [ cx1, cy1, cx2, cy2, x, y ] = args;\n\t\t\tconst curve = new Bezier(previous.x, previous.y, cx1, cy1, cx2, cy2, x, y);\n\t\t\tconst dist = curve.length();\n\n\t\t\t// update the total length\n\t\t\t// end = start + dist; \n\t\t\tdistance += dist;\n\n\t\t\t// replace this command\n\t\t\tpoints.push({ isBezier: true, points: args, x, y, dist, curve });\n\t\t}\n\t\t// no quadratic curves\n\t\telse if (args.length === 4) {\n\t\t\tthrow 'Quadradic curves are not supported';\n\t\t}\n\t}\n\n\treturn { points, distance };\n}\n\n\n// generate the progress from the svg path\nfunction createProgress(points, distance, offsetY, height) {\n\tconst progress = [ ];\n\n\t// normalizes each y-axis point as a percentage, so the lower\n\t// the y value is actually more progress\n\tconst normalizePoint = y => {\n\t\t// round the number to two decimal places\n\t\treturn (0 | (1 - ((y - offsetY) / height)) * 100) / 100;\n\t};\n\n\t// with the known length, calculate the points along each\n\t// path to account for their space. This also \n\tlet index = 1;\n\tlet max = 0;\n\tconst scale = 1;\n\tconst samples = 100 * scale;\n\n\t// calculate the preferred number of samples for the progress\n\twhile (max < samples) {\n\t\tconst current = points[index];\n\t\tconst segment = Math.round(samples * (current.dist / distance));\n\n\t\t// get the percentage distance\n\t\tmax += segment;\n\n\t\t// sample the required points for a curve\n\t\t// and save all y/axis values\n\t\tif (current.isBezier) {\n\t\t\tconst lut = current.curve.getLUT(segment);\n\t\t\tfor (const point of lut) {\n\t\t\t\tconst t = normalizePoint(point.y)\n\t\t\t\tprogress.push(t);\n\t\t\t}\n\t\t}\n\t\t// for a line, just interpolate the y position\n\t\telse if (current.isLine) {\n\t\t\tconst previous = points[index - 1];\n\t\t\tfor (let i = 0; i < segment; i++) {\n\t\t\t\tconst y = previous.y + ((current.y - previous.y) * (i / segment));\n\t\t\t\tconst t = normalizePoint(y);\n\t\t\t\tprogress.push(t);\n\t\t\t}\n\t\t}\n\t\t// shouldn't happen, but if the point type\n\t\t// is unexpected, complain about it\n\t\telse {\n\t\t\tthrow 'Unexpected point type in path'\n\t\t}\n\n\t\t// continue forward\n\t\tindex++;\n\t}\n\n\treturn progress;\n}","import _ from 'lodash';\nimport fs from 'fs-extra';\nimport path from 'path';\nimport * as cache from './cache.js';\nimport paths, { replacePaths } from './paths.js';\n\n// resource generation approaches\nimport generateResource from './generate-resource.js';\nimport generateResourcesFromDirectory from './generate-resource-from-dir.js';\nimport scanDirectory from './scan-directory.js';\nimport generateSoundsSpritesheet from './generate-sounds-spritesheet.js';\nimport { compileProgressPath } from './compile-progress-path.js';\n\n// check if debugging mode should be used\nconst DEBUG = !!~process.argv.indexOf('--debug');\n\n/** handles compiling all resources in the repo folder */\nexport async function compile(inputDir, outputDir) {\n\t\n\t// change the input/output directories\n\tif (inputDir && outputDir) {\n\t\treplacePaths(inputDir, outputDir);\n\t}\n\n\t// prepare the data\n\tconst { INPUT_DIR, OUTPUT_DIR } = paths;\n\tconst exported = path.resolve(`${OUTPUT_DIR}/manifest.json`);\n\n\t// load the previous document into the cache\n\tawait cache.load(exported);\n\n\t// ensure directories\n\tawait fs.mkdirp(OUTPUT_DIR);\n\n\t// TODO: restore data\n\t// check for changes\n\tconst data = { };\n\tif (!('spritesheets' in data)) data.spritesheets = { };\n\tif (!('tracks' in data)) data.tracks = { };\n\n\t// start generating files\n\tawait generateResource(data, data, 'particles', { });\n\tawait generateResource(data, data, 'images', { });\n\tawait generateResource(data, data, 'animations', { });\n\tawait generateResource(data, data, 'emitters', { });\n\tawait generateResource(data, data, 'crowd', { });\n\t\n\t// generate resources that have sub files\n\tawait generateResourcesFromDirectory(data, data.trails, 'trails', { });\n\tawait generateResourcesFromDirectory(data, data.intro, 'intros', { });\n\tawait generateResourcesFromDirectory(data, data.nitros, 'nitros', { });\n\tawait generateResourcesFromDirectory(data, data.cars, 'cars', { });\n\tawait generateResourcesFromDirectory(data, data.namecards, 'namecards', { });\n\tawait generateResourcesFromDirectory(data, data.extras, 'extras', { });\n\n\t// tracks have variations so each directory should\n\t// be scanned to see all available types\n\tawait scanDirectory(`${INPUT_DIR}/tracks`, { }, async (trackName, fullTrackDir) => {\n\n\t\t// save the track node\n\t\tdata.tracks[trackName] = { };\n\n\t\t// create all variations\n\t\tawait scanDirectory(fullTrackDir, { }, async variant => {\n\t\t\tdata.tracks[trackName][variant] = { };\n\n\t\t\t// generate a resource per variation\n\t\t\tawait generateResource(data, data.tracks[trackName], variant, { \n\t\t\t\tsubdir: `tracks/${trackName}`\n\t\t\t});\n\t\t});\n\t});\n\n\n\t// create the sounds, if needed\n\tawait generateSoundsSpritesheet(data);\n\n\t// compile the path progress helper\n\tdata.progress = await compileProgressPath();\n\n\t// include animation data\n\tconst animations = await fs.readFile(`${INPUT_DIR}/crowd/animations.json`);\n\tdata.crowd = JSON.parse(animations.toString());\n\n\t// save the completed file\n\tconst generated = JSON.stringify(data, null, DEBUG ? 2 : null);\n\tconsole.log(`[export] ${exported}`);\n\tawait fs.writeFile(exported, generated);\n}\n","export { compile } from './compile.js';\nimport * as allUtils from './utils.js';\nexport const utils = allUtils;","import express from 'express';\nimport path from 'path';\nimport chokidir from 'chokidar';\nimport Bundler from 'parcel-bundler';\nimport { compile } from '../compile';\nimport Server from 'simple-websocket/server';\n\n// shared config\nlet CONFIG;\nlet ROOT;\n\n// web socket communication\nlet ws;\nlet connections = [ ];\n\n// kicks off the process\nexport async function serve(config) {\n\tCONFIG = config;\n\n\t// get the root of the nt-composer module\n\t// ???: search for package.json\n\tconst [ entry, script ] = process.argv;\n\tROOT = path.dirname(script);\n\n\t// if this was called as a binary, we need to resolve to\n\t// the root of the node module\n\t// NOTE: I don't normally do this, so I don't know the\n\t// best practices for something like this\n\tif (/\\.bin$/.test(ROOT)) {\n\t\tROOT = path.dirname(ROOT);\n\t\tROOT = path.resolve(ROOT, 'nt-composer');\n\t}\n\n\t// set some defaults\n\tif (isNaN(CONFIG.port) || CONFIG.port < 1000) CONFIG.port = 9999;\n\n\t// check for the development bundler\n\tlet bundler;\n\n\t// create the bundler which is just serving\n\t// the index html file\n\tif (config.dev) {\n\t\tconsole.log('[mode] using dev mode');\n\t\tbundler = new Bundler(`${ROOT}/preview/index.html`, {\n\t\t\toutDir: './.preview/client',\n\t\t\tsourceMaps: true,\n\t\t\tcache: false\n\t\t});\n\t}\n\n\t// create the app\n\tconst app = express();\n\n\t// communicate for websockets\n\tconfigureWebSockets();\n\n\t// use pre-compiled track/animator\n\tif (!config.dev) {\n\t\tapp.use(express.static(`${ROOT}/dist/client`));\n\t}\n\n\t// share the root to allow access to node_modules\n\t// primarily to allow access to source maps\n\tapp.use(express.static(`${ROOT}/node_modules`));\n\n\t// access to non-compiled assets\n\tapp.use(express.static(`${ROOT}/public`));\n\n\t// access to compiled assets and spritesheets\n\tapp.use(express.static(CONFIG.output));\n\n\t// wait for changes\n\tchokidir.watch(CONFIG.input)\n\t\t.on('add', queueCompileAssets)\n\t\t.on('change', queueCompileAssets)\n\t\t.on('unlink', queueCompileAssets);\n\n\t// inject parcel bundler\n\tif (config.dev) {\n\t\tapp.use(bundler.middleware());\n\t}\n\n\t// waits for assets to compile\n\tawait waitForAssets();\n\n\t// start listening\n\tconsole.log(`NT Previewer now ready at http://localhost:${CONFIG.port}`);\n\tapp.listen(CONFIG.port);\n\t\n}\n\n// prepares a socket handler to communicate when\n// assets are updated\nfunction configureWebSockets() {\n\n\t// create the server\n\tws = new Server({ port: CONFIG.port + 1 });\n\n\t// wait for connections\n\tws.on('connection', socket => {\n\n\t\t// cleanup\n\t\tsocket.on('end', () => {\n\t\t\tconst index = connections.indexOf(socket);\n\t\t\tconnections.splice(index, 1);\n\t\t});\n\n\t\t// add to active connections\n\t\tconnections.push(socket);\n\t});\n}\n\n// queues waiting for assets to finish compiling\nlet waitingForAssets;\nfunction waitForAssets() {\n\treturn new Promise(resolve => waitingForAssets = resolve);\n}\n\n// watch for changes\nlet pendingRefresh;\nfunction queueCompileAssets() {\n\tclearTimeout(pendingRefresh);\n\tpendingRefresh = setTimeout(compileAssets, 1000);\n}\n\n// send a message to active connections\nfunction notifyConnections(message) {\n\tfor (const socket of connections) {\n\t\ttry { socket.send(message); }\n\t\tcatch (ex) { }\n\t}\n}\n\n// kicks off the compile process\nasync function compileAssets() {\n\n\tconsole.log('\\n\\nCompiling assets\\n');\n\tnotifyConnections('pending');\n\n\t// wait for the compile\n\ttry {\n\t\tawait compile(CONFIG.input, CONFIG.output);\n\t\tnotifyConnections('refresh');\n\t\tconsole.log('\\nAssets compiled\\n\\n');\n\t}\n\tcatch (ex) {\n\t\tnotifyConnections('error');\n\t\tconsole.log('\\nAssets compile error\\n\\n');\n\t\tconsole.log(ex);\n\t}\n\t\n\t// ready to show\n\tif (waitingForAssets) {\n\t\twaitingForAssets();\n\t}\n}\n"]}