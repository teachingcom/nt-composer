{"version":3,"sources":["../compile/cache.js","../compile/paths.js","../compile/utils.js","../compile/compression.json","../compile/generate-spritesheet.js","../compile/generate-resource.js","../compile/scan-directory.js","../compile/generate-resource-from-dir.js","../compile/generate-sounds-spritesheet.js","../compile/splitManifest.js","../compile/compile.js","../compile/index.js","server.js"],"names":["data","load","path","content","fs","readFile","parsed","JSON","parse","toString","Object","assign","ex","paths","exec","script","INPUT_DIR","OUTPUT_DIR","process","argv","resolve","replacePaths","inputDir","outputDir","readYml","exists","contents","yml","console","error","getDirectoryContents","dir","markup","images","files","readdir","file","source","stat","isDirectory","lastModified","mtime","ext","extname","ref","indexOf","push","asyncCallback","action","args","Promise","reject","err","res","fileToKey","_","snakeCase","basename","timeout","time","setTimeout","module","exports","jpeg_quality","png_max_palette_colors","COMPRESSION_PARAMS","JPG_COMPRESSION_ARGS","PNG_COMPRESSION_ARGS","generateSpritesheet","spritesheets","nodeId","spritesheetName","subdir","spritesheetId","basePath","pngPath","jpgPath","jpgs","filter","item","test","pngs","hasPngs","some","hasJpgs","generatedTimes","getModifiedTime","lastGenerated","expired","Math","min","apply","isNaN","existing","get","cache","log","sprites","version","Date","now","hasPng","createSpritesheetFromImages","hasJpg","tmpId","resourceDir","dirname","substr","length","tmpDir","mkdirp","compress_force","statistic","autoupdate","jpg","engine","command","png","svg","gif","completed","remove","saveTo","isTrack","padding","src","map","image","coordinates","Spritesmith","run","bounds","name","Error","x","y","width","height","target","writeFile","statSync","generateResource","root","node","id","options","pathId","key","scanDirectory","dirs","location","isHidden","allowType","allowFiles","allowHidden","generateResourcesFromDirectory","isMP3","generateSoundSprites","input","entries","entry","copyMP3s","tmp","output","gap","generated","sounds","spritemap","sound","start","end","compare","existsSync","readdirSync","copyFrom","copyTo","copyAndCompressAudio","on","audioBitrate","audioChannels","mergeToFile","SECTIONS","splitManifest","manifest","type","obj","standard","stringify","keys","DEBUG","VERSION","compile","exported","tracks","trails","intro","nitros","cars","namecards","extras","trackName","fullTrackDir","variant","utils","allUtils","CONFIG","ROOT","ws","waitingForAssets","pendingRefresh","connections","serve","config","bundler","resources","port","dev","Bundler","outDir","sourceMaps","app","configureWebSockets","use","express","static","watch","queueCompileAssets","middleware","waitForAssets","listen","Server","socket","index","splice","clearTimeout","compileAssets","notifyConnections","message","send"],"mappings":"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","file":"server.js","sourceRoot":"../preview","sourcesContent":["import fs from 'fs-extra'\n\n/** the previous version of the file */\nexport const data = { }\n\n// tries to load the previous document, if any\nexport async function load (path) {\n  try {\n    const content = await fs.readFile(path)\n    const parsed = JSON.parse(content.toString())\n    Object.assign(data, parsed)\n    // wasn't able to restore the file\n  } catch (ex) { }\n}\n","import path from 'path';\nconst [ exec, script, INPUT_DIR, OUTPUT_DIR ] = (process.argv || [ ]);\n\n// get the root path\nconst paths = { \n\tOUTPUT_DIR: path.resolve(INPUT_DIR || ''),\n\tINPUT_DIR: path.resolve(OUTPUT_DIR || ''),\n};\n\nexport function replacePaths(inputDir, outputDir) {\n\tpaths.INPUT_DIR = inputDir;\n\tpaths.OUTPUT_DIR = outputDir;\n}\n\nexport default paths;","import _ from 'lodash';\nimport fs from 'fs-extra';\nimport path from 'path';\nimport yml from 'js-yaml';\n\n/** reads a YML file */\nexport async function readYml(path) {\n\n\t// make sure this exists\n\tconst exists = await fs.exists(path);\n\tif (!exists) return null;\n\n\t// try and read the content\n\ttry {\n\t\tconst contents = await fs.readFile(path);\n\t\treturn yml.load(contents.toString());\n\t}\n\tcatch (ex) {\n\t\tconsole.error(`YAML Error in ${path}`);\n\t\tthrow ex;\n\t}\n}\n\n/** gather up contents for a directory */\nexport async function getDirectoryContents(dir) {\n\tlet markup = [ ];\n\tlet images = [ ];\n\n\t// get modified times for each file\n\tconst files = await fs.readdir(dir);\n\tfor (let file of files) {\n\n\t\t// get the source\n\t\tconst source = path.resolve(`${dir}/${file}`);\n\t\tconst stat = await fs.stat(source);\n\t\tconst isDirectory = stat.isDirectory();\n\t\tconst lastModified = +stat.mtime;\n\t\tconst ext = path.extname(file);\n\t\t\n\t\t// skip directories and hidden files\n\t\tif (isDirectory || file[0] === '.') continue;\n\n\t\t// add to the correct group\n\t\tconst ref = !!~['.yml', '.yaml'].indexOf(ext) ? markup\n\t\t\t: !!~['.jpg', '.jpeg', '.png'].indexOf(ext) ? images\n\t\t\t: null;\n\n\t\t// create the record\n\t\tif (ref) ref.push({ path: source, lastModified });\n\t}\n\n\treturn { markup, images };\n}\n\n/** perfoms a callback as an async call */\nexport async function asyncCallback(action, ...args) {\n\treturn new Promise((resolve, reject) => {\n\t\taction(...args, (err, ...res) => {\n\t\t\tif (err) reject(err);\n\t\t\telse resolve(...res);\n\t\t});\n\t});\n}\n\n/** generates a key from a file name or path */\nexport function fileToKey(file) {\n\treturn _.snakeCase(path.basename(file, path.extname(file)))\n}\n\n/** waits a specified time */\nexport async function timeout(time) {\n\treturn new Promise(resolve => {\n\t\tsetTimeout(resolve, time);\n\t});\n}","module.exports={jpeg_quality:80,png_max_palette_colors:128};","import _ from 'lodash'\nimport fs from 'fs-extra'\nimport path from 'path'\nimport Spritesmith from 'spritesmith'\nimport compressImages from 'compress-images'\n\nimport COMPRESSION_PARAMS from './compression.json'\nimport { fileToKey, asyncCallback, timeout } from './utils.js'\nimport paths from './paths.js'\nimport * as cache from './cache.js'\n\n// compression args\nconst { jpeg_quality, png_max_palette_colors } = COMPRESSION_PARAMS\nconst JPG_COMPRESSION_ARGS = ['-quality', jpeg_quality]\nconst PNG_COMPRESSION_ARGS = [png_max_palette_colors, '-f', '--strip', '--skip-if-larger']\n\nexport async function generateSpritesheet (spritesheets, nodeId, spritesheetName, subdir, images) {\n  const { OUTPUT_DIR } = paths\n  const spritesheetId = `${subdir}${spritesheetName || nodeId}`\n\n  // get the possible paths\n  const basePath = path.resolve(`${OUTPUT_DIR}/${spritesheetId}`)\n  const pngPath = `${basePath}.png`\n  const jpgPath = `${basePath}.jpg`\n\n  // check for certain type\n  const jpgs = _.filter(images, item => /jpe?g$/i.test(item.path))\n  const pngs = _.filter(images, item => /png$/i.test(item.path))\n\n  // check for available images\n  const hasPngs = _.some(pngs)\n  const hasJpgs = _.some(jpgs)\n\n  // check each time, but only if the image type is expected\n  const generatedTimes = []\n  if (hasPngs) generatedTimes.push(getModifiedTime(pngPath))\n  if (hasJpgs) generatedTimes.push(getModifiedTime(jpgPath))\n  let lastGenerated = Math.min.apply(Math, generatedTimes)\n  if (isNaN(lastGenerated)) lastGenerated = 0\n\n  // if all of the images have a lower write time\n  // than the sprite sheet then we don't need to compile it again\n  let expired\n  for (const item of images) {\n    expired = expired || item.lastModified > lastGenerated\n  }\n\n  // check and make sure the prior data is available\n  const existing = _.get(cache.data, 'spritesheets', { })[spritesheetId]\n\n  // if it's not expired and we have the old info then\n  // we can just reuse it\n  if (!expired && existing) {\n    spritesheets[spritesheetId] = existing\n    return\n  }\n\n  // notify of params\n  console.log(`New Compress Compression Params\n  jpeg_quality           : ${jpeg_quality}\n  png_max_palette_colors : ${png_max_palette_colors}`)\n\n  // save the new spritesheet location\n  const sprites = spritesheets[spritesheetId] = { }\n  sprites.version = Date.now().toString(16)\n\n  // generate PNGs\n  if (hasPngs) {\n    sprites.hasPng = true\n    await createSpritesheetFromImages(spritesheetId, sprites, pngs, pngPath)\n  }\n\n  // generate JPGs\n  if (hasJpgs) {\n    sprites.hasJpg = true\n    await createSpritesheetFromImages(spritesheetId, sprites, jpgs, jpgPath)\n  }\n\n  // there seems to be some timing issues - give a moment to\n  // settle down before compressing - ideally, we can just\n  // pipe results eventually\n  await timeout(500)\n\n  // verify the resource directory\n  const tmpId = _.snakeCase(spritesheetId)\n  const resourceDir = `dist${path.dirname(basePath).substr(OUTPUT_DIR.length)}`\n  const tmpDir = `${resourceDir}/_${tmpId}`\n  await fs.mkdirp(resourceDir)\n\n  // compress resources\n  return new Promise((resolve, reject) => {\n    compressImages(\n      `${tmpDir}/*.{jpg,png}`, // input\n      `${resourceDir}/`, // output\n      {\n        compress_force: true,\n        statistic: true,\n        autoupdate: false\n      },\n      false, // ??\n      { jpg: { engine: 'mozjpeg', command: JPG_COMPRESSION_ARGS } },\n      { png: { engine: 'pngquant', command: PNG_COMPRESSION_ARGS } },\n      { svg: { engine: false, command: false } },\n      { gif: { engine: false, command: false } },\n\n      // finalize\n      async function (error, completed, statistic) {\n        // remove the temporary generation dir\n        fs.remove(tmpDir)\n\n        // check for errors\n        if (error) {\n          console.error(`Compression failure for ${resourceDir}`)\n          console.error(error)\n          resolve()\n          // compressed as expected\n        } else {\n          resolve()\n        }\n      })\n  })\n}\n\n// updates the spritesheet with image names\nasync function createSpritesheetFromImages (spritesheetId, sprites, images, saveTo) {\n\n  // this is not ideal, but for some reason\n  // padding on tracks actually creates tears in\n  // the road - this is a temp fix\n  const isTrack = /tracks\\//.test(saveTo)\n  const padding = isTrack ? 0 : 3\n\n  // convert to a spritesheet\n  const src = _.map(images, item => item.path)\n  const { image, coordinates } = await asyncCallback(Spritesmith.run, { padding, src })\n  const ext = path.extname(saveTo).substr(1)\n\n  // simplify the output format\n  for (const file in coordinates) {\n    const bounds = coordinates[file]\n    const name = fileToKey(file)\n\n    // if this name already exists, then there's a conflict in\n    // names and needs to be stopped\n    if (sprites[name]) {\n      throw new Error(`Conflicting sprite name: ${name} in ${spritesheetId}`)\n    }\n\n    sprites[name] = [bounds.x, bounds.y, bounds.width, bounds.height, ext]\n  }\n\n  // write the image\n  const tmpId = _.snakeCase(spritesheetId)\n  const dir = `${path.dirname(saveTo)}/_${tmpId}`\n  const target = `${dir}/${path.basename(saveTo)}`\n  await fs.mkdirp(dir)\n  await fs.writeFile(target, image, 'binary')\n}\n\n// check the last modified time for a file, if it exists\nfunction getModifiedTime (path) {\n  try {\n    return fs.statSync(path).mtime || 0\n  } catch (ex) {\n    return 0\n  }\n}\n","import _ from 'lodash'\nimport fs from 'fs-extra'\nimport path from 'path'\n\nimport { getDirectoryContents, readYml, fileToKey } from './utils.js'\nimport { generateSpritesheet } from './generate-spritesheet.js'\nimport paths from './paths.js'\n\n/** generates a resource item */\nexport default async function generateResource (root, node, id, options) {\n  const { INPUT_DIR } = paths\n  const hasSubdir = !!options.subdir\n  const subdir = hasSubdir ? `${options.subdir}/` : ''\n  const pathId = `${subdir}${id}`\n  const dir = path.resolve(`${INPUT_DIR}/${pathId}`)\n  const nodeId = options.nodeId || id\n\n  // if it's missing, don't bother\n  // there will be a separate process to remove\n  // files that no longer exist so cleanup is not required\n  const exists = await fs.exists(dir)\n  if (!exists) return\n\n  // gather file contents\n  console.log('[generating]', pathId)\n  const { images, markup } = await getDirectoryContents(dir, options)\n\n  // copy all YML data\n  const data = { }\n  for (const item of markup) {\n    const contents = await readYml(item.path)\n    const key = fileToKey(item.path)\n\n    // assign the data -- for a default index file, just assign the data\n    if (key === 'index') Object.assign(data, contents)\n    else data[key] = contents\n  }\n\n  // save the data, if any\n  if (_.some(data)) {\n    node[nodeId] = data\n  }\n\n  // generate the spritesheet, if any\n  if (_.some(images)) {\n    const { spritesheetName } = options\n    await generateSpritesheet(root.spritesheets, id, spritesheetName, subdir, images)\n  }\n}\n","import path from 'path';\nimport fs from 'fs-extra';\n\n/** handles checking a directory for content */\nexport default async function scanDirectory(source, options, action) {\n\n\t// doesn't exist yet\n\tconst exists = await fs.exists(source);\n\tif (!exists) return;\n\n\t// gather all sub folders\n\tconst dirs = await fs.readdir(source);\n\tfor (const dir of dirs) {\n\n\t\t// make sure it's not a hidden file and\n\t\t// is actually a directory\n\t\tconst location = path.resolve(`${source}/${dir}`);\n\t\tconst stat = await fs.stat(location);\n\t\tconst isHidden = dir[0] === '.';\n\t\tconst isDirectory = stat.isDirectory();\n\t\tconst allowType = isDirectory || (!isDirectory && options.allowFiles);\n\t\tconst allowHidden = !isHidden || (isHidden && options.allowHidden);\n\n\t\t// continue with this resource\n\t\tif (allowType && allowHidden) \n\t\t\tawait action(dir, location);\n\t}\n\n}","import path from 'path';\nimport paths from './paths.js';\nimport generateResource from './generate-resource.js';\nimport scanDirectory from './scan-directory.js';\n\n/** generates a resource from each item in a directory */\nexport default async function generateResourcesFromDirectory(root, node, id, options) {\n\tconst { INPUT_DIR } = paths;\n\tconst source = path.resolve(`${INPUT_DIR}/${id}`);\n\t\n\t// if the node is missing, create it\n\tif (!node) {\n\t\tnode = { };\n\t\troot[id] = node;\n\t}\n\n\t// process all diles in a directory\n\tawait scanDirectory(source, { }, async dir => {\n\t\tawait generateResource(root, node, dir, { nodeId: dir, subdir: id });\n\t});\n}","import fs from 'fs-extra'\nimport path from 'path'\nimport fluent from 'fluent-ffmpeg'\nimport audiosprite from 'audiosprite'\nimport paths from './paths.js'\nimport { equalFiles } from 'file-sync-cmp'\n\nconst isMP3 = path => /\\.mp3$/i.test(path)\n\nexport default async function generateSoundSprites (root) {\n  const { INPUT_DIR, OUTPUT_DIR } = paths\n  const dir = 'sounds'\n  const input = path.resolve(INPUT_DIR, dir)\n\n  // collect possible sprites\n  const files = []\n  const entries = await fs.readdir(input)\n  for (const entry of entries) {\n    // filter out hidden files\n    if (/^\\./i.test(entry)) continue\n\n    // check the file info\n    const file = path.resolve(input, entry)\n    const stat = await fs.stat(file)\n\n    // if is an mp3 file\n    if (isMP3(file)) {\n      files.push(file)\n\n    // is a directory, then just copy the files\n    } else if (stat.isDirectory()) {\n      await copyMP3s(`${dir}/${entry}`)\n    }\n  }\n\n  // check for required files\n  return new Promise((resolve, reject) => {\n    const tmp = path.resolve('./.compiled-audio')\n    const output = path.resolve(OUTPUT_DIR, 'sounds')\n    const options = {\n      gap: 0.5,\n      output: `${tmp}/common`\n    }\n\n    // create the spritesheet\n    audiosprite(files, options, async (err, generated) => {\n      if (err) {\n        return reject(err)\n      }\n\n      // map all audio files\n      root.sounds = { }\n      for (const id in generated.spritemap) {\n        const sound = generated.spritemap[id]\n        root.sounds[id] = [0 | sound.start * 1000, 0 | (sound.end - sound.start) * 1000]\n      }\n\n      // compare the spritesheets to determine if they\n      // changed, and if so, update the timestamp\n      const source = `${tmp}/common.mp3`\n      const compare = `${output}/common.mp3`\n      const hasExisting = fs.existsSync(compare)\n      const same = hasExisting && equalFiles(source, compare)\n      if (!same) {\n        root.sounds.version = Date.now().toString('16')\n        console.log('[audio] updated version: common.mp3')\n\n        // copy and compress each\n        const files = fs.readdirSync(tmp)\n        for (const file of files) {\n          const copyFrom = path.resolve(tmp, file)\n          const copyTo = path.resolve(output, file)\n          await copyAndCompressAudio(copyFrom, copyTo)\n        }\n      }\n\n      resolve()\n    })\n  })\n}\n\n// copy and compress each MP3 in a directory\nasync function copyMP3s(dir) {\n  const { INPUT_DIR, OUTPUT_DIR } = paths\n  const input = path.resolve(INPUT_DIR, dir)\n  const output = path.resolve(OUTPUT_DIR, dir)\n\n  const entries = await fs.readdir(input)\n  for (const entry of entries) {\n    // ensure it's an mp3\n    if (!isMP3(entry)) continue\n\n    // make the directory, if needed\n    const exists = await fs.exists(output)\n    if (!exists) await fs.mkdirp(output)\n\n    // copy the file\n    const source = path.resolve(input, entry)\n    const target = path.resolve(output, entry)\n\n    // copy the compressed version\n    await copyAndCompressAudio(source, target)\n    console.log(`[audio] ${dir}/${entry}`)\n  }\n}\n\n// handles copying individual MP3 files\nasync function copyAndCompressAudio(input, output) {\n  return new Promise((resolve, reject) => {\n    fluent()\n\n      // get the file top copy\n      .input(input)\n\n      // handle events\n      .on('end', resolve)\n      .on('error', reject)\n\n      // configure audio\n      .audioBitrate(48)\n      .audioChannels(1)\n\n      // then merge it\n      .mergeToFile(output)\n  })\n}\n","import fs from 'fs-extra'\nimport path from 'path'\n\nconst SECTIONS = ['trails', 'nitros', 'cars', 'namecards']\n\nexport default async function splitManifest ({ manifest, outputDir }) {\n  // save each asset type as a separate file\n  for (const type of SECTIONS) {\n    console.log(`[manifest] creating external manifests for ${type}`)\n    const dir = path.resolve(outputDir, `./${type}`)\n\n    // remove all existing JSON files first\n    if (fs.existsSync(dir)) {\n      const files = await fs.readdir(dir)\n      for (const file of files) {\n        if (path.extname(file) === '.json') {\n          const remove = path.resolve(dir, file)\n          await fs.remove(remove)\n        }\n      }\n    }\n\n    // copy each type into its own file\n    for (const id in manifest[type]) {\n      const obj = manifest[type][id]\n\n      // is standard and shoul be included\n      // in the default manifest\n      if (obj.standard) {\n        continue\n      }\n\n      // should be dynamically loaded\n      const output = JSON.stringify(obj)\n      const target = path.resolve(`${dir}/${id}.json`)\n      await fs.writeFile(target, output)\n\n      // remove this item\n      delete manifest[type][id]\n    }\n\n    // remove the manifest section if nothing remains\n    if (Object.keys(manifest[type]).length === 0) {\n      delete manifest[type]\n    }\n  }\n}\n","import fs from 'fs-extra'\nimport path from 'path'\nimport * as cache from './cache.js'\nimport paths, { replacePaths } from './paths.js'\n\n// resource generation approaches\nimport generateResource from './generate-resource.js'\nimport generateResourcesFromDirectory from './generate-resource-from-dir.js'\nimport scanDirectory from './scan-directory.js'\nimport generateSoundsSpritesheet from './generate-sounds-spritesheet.js'\nimport splitManifest from './splitManifest.js'\n\n// check if debugging mode should be used\nconst DEBUG = !!~process.argv.indexOf('--debug')\nconst VERSION = '1.1.8'\n\n/** handles compiling all resources in the repo folder */\nexport async function compile (inputDir, outputDir) {\n  // it's somewhat difficult to ensure the composer is\n  // the correct version when used from different repos\n  // this will make it known which version is being run\n  console.log(`nt-composer: v${VERSION}`)\n\n  // change the input/output directories\n  if (inputDir && outputDir) {\n    replacePaths(inputDir, outputDir)\n  }\n\n  // prepare the data\n  const { INPUT_DIR, OUTPUT_DIR } = paths\n  const exported = path.resolve(`${OUTPUT_DIR}/manifest.json`)\n\n  // load the previous document into the cache\n  await cache.load(exported)\n\n  // ensure directories\n  await fs.mkdirp(OUTPUT_DIR)\n\n  // TODO: restore data\n  // check for changes\n  const data = { }\n  if (!('spritesheets' in data)) data.spritesheets = { }\n  if (!('tracks' in data)) data.tracks = { }\n\n  // start generating files\n  await generateResource(data, data, 'particles', { })\n  await generateResource(data, data, 'images', { })\n  await generateResource(data, data, 'animations', { })\n  await generateResource(data, data, 'emitters', { })\n  await generateResource(data, data, 'crowd', { })\n\n  // generate resources that have sub files\n  await generateResourcesFromDirectory(data, data.trails, 'trails', { })\n  await generateResourcesFromDirectory(data, data.intro, 'intros', { })\n  await generateResourcesFromDirectory(data, data.nitros, 'nitros', { })\n  await generateResourcesFromDirectory(data, data.cars, 'cars', { })\n  await generateResourcesFromDirectory(data, data.namecards, 'namecards', { })\n  await generateResourcesFromDirectory(data, data.extras, 'extras', { })\n\n  // tracks have variations so each directory should\n  // be scanned to see all available types\n  await scanDirectory(`${INPUT_DIR}/tracks`, { }, async (trackName, fullTrackDir) => {\n    // save the track node\n    data.tracks[trackName] = { }\n\n    // create all variations\n    await scanDirectory(fullTrackDir, { }, async variant => {\n      data.tracks[trackName][variant] = { }\n\n      // generate a resource per variation\n      await generateResource(data, data.tracks[trackName], variant, {\n        subdir: `tracks/${trackName}`\n      })\n    })\n  })\n\n  // create the sounds, if needed\n  await generateSoundsSpritesheet(data)\n\n  // save a version number to force manifest files\n  // to reload with\n  data.version = Date.now().toString('16')\n\n  // break up non-required manifest data\n  await splitManifest({ manifest: data, outputDir: OUTPUT_DIR })\n\n  // save the completed file\n  const output = JSON.stringify(data, null, DEBUG ? 2 : null)\n  console.log(`[export] ${exported}`)\n  await fs.writeFile(exported, output)\n}\n","export { compile } from './compile.js';\nimport * as allUtils from './utils.js';\nexport const utils = allUtils;","import express from 'express';\nimport path from 'path';\nimport chokidir from 'chokidar';\nimport Bundler from 'parcel-bundler';\nimport { compile } from '../compile';\nimport Server from 'simple-websocket/server';\n\n// shared config\nlet CONFIG;\nlet ROOT;\n\n// web socket communication\nlet ws;\nlet connections = [ ];\n\n// kicks off the process\nexport async function serve(config) {\n\tCONFIG = config;\n\n\t// get the root of the nt-composer module\n\t// ???: search for package.json\n\t// const [ entry, script ] = process.argv;\n\tROOT = path.dirname(config.resources);\n\n\t// if this was called as a binary, we need to resolve to\n\t// the root of the node module\n\t// NOTE: I don't normally do this, so I don't know the\n\t// best practices for something like this\n\tif (/\\.bin$/.test(ROOT)) {\n\t\tROOT = path.dirname(ROOT);\n\t\tROOT = path.resolve(ROOT, 'nt-composer');\n\t}\n\n\t// set some defaults\n\tif (isNaN(CONFIG.port) || CONFIG.port < 1000) CONFIG.port = 9999;\n\n\t// check for the development bundler\n\tlet bundler;\n\n\t// create the bundler which is just serving\n\t// the index html file\n\tif (config.dev) {\n\t\tconsole.log('[mode] using dev mode2');\n\t\tbundler = new Bundler(`${ROOT}/preview/index.html`, {\n\t\t\toutDir: './.preview/client',\n\t\t\tsourceMaps: true,\n\t\t\tcache: false\n\t\t});\n\t}\n\t\n\t// create the app\n\tconst app = express();\n\t\n\t// communicate for websockets\n\tconfigureWebSockets();\n\t\n\t// use pre-compiled track/animator\n\tif (!config.dev) {\n\t\tapp.use(express.static(`${ROOT}/dist/client`));\n\t}\n\t// precompiled\n\telse {\n\t\tapp.use(express.static('./.preview/client'));\n\t\tapp.use(express.static(`${ROOT}/dist`));\n\t}\n\n\t// share the root to allow access to node_modules\n\t// primarily to allow access to source maps\n\tapp.use(express.static(`${ROOT}/node_modules`));\n\n\t// access to non-compiled assets\n\tapp.use(express.static(`${ROOT}/public`));\n\n\t// access to compiled assets and spritesheets\n\tapp.use(express.static(CONFIG.output));\n\n\t// wait for changes\n\tchokidir.watch(CONFIG.input)\n\t\t.on('add', queueCompileAssets)\n\t\t.on('change', queueCompileAssets)\n\t\t.on('unlink', queueCompileAssets);\n\n\t// inject parcel bundler\n\tif (config.dev) {\n\t\tapp.use(bundler.middleware());\n\t}\n\n\t// waits for assets to compile\n\tawait waitForAssets();\n\n\t// start listening\n\tconsole.log(`NT Previewer now ready at http://localhost:${CONFIG.port}`);\n\tapp.listen(CONFIG.port);\n\t\n}\n\n// prepares a socket handler to communicate when\n// assets are updated\nfunction configureWebSockets() {\n\n\t// create the server\n\tws = new Server({ port: CONFIG.port + 1 });\n\n\t// wait for connections\n\tws.on('connection', socket => {\n\n\t\t// cleanup\n\t\tsocket.on('end', () => {\n\t\t\tconst index = connections.indexOf(socket);\n\t\t\tconnections.splice(index, 1);\n\t\t});\n\n\t\t// add to active connections\n\t\tconnections.push(socket);\n\t});\n}\n\n// queues waiting for assets to finish compiling\nlet waitingForAssets;\nfunction waitForAssets() {\n\treturn new Promise(resolve => waitingForAssets = resolve);\n}\n\n// watch for changes\nlet pendingRefresh;\nfunction queueCompileAssets() {\n\tclearTimeout(pendingRefresh);\n\tpendingRefresh = setTimeout(compileAssets, 1000);\n}\n\n// send a message to active connections\nfunction notifyConnections(message) {\n\tfor (const socket of connections) {\n\t\ttry { socket.send(message); }\n\t\tcatch (ex) { }\n\t}\n}\n\n// kicks off the compile process\nasync function compileAssets() {\n\n\tconsole.log('\\n\\nCompiling assets\\n');\n\tnotifyConnections('pending');\n\n\t// wait for the compile\n\ttry {\n\t\tawait compile(CONFIG.input, CONFIG.output);\n\t\tnotifyConnections('refresh');\n\t\tconsole.log('\\nAssets compiled\\n\\n');\n\t}\n\tcatch (ex) {\n\t\tnotifyConnections('error');\n\t\tconsole.log('\\nAssets compile error\\n\\n');\n\t\tconsole.log(ex);\n\t}\n\t\n\t// ready to show\n\tif (waitingForAssets) {\n\t\twaitingForAssets();\n\t}\n}\n"]}